Smoothing the Landscape Boosts the Signal for SGD
Optimal Sample Complexity for Learning Single Index Models
Alex Damian
Princeton University
ad27@princeton.edu
Eshaan Nichani
Princeton University
eshnich@princeton.edu
Rong Ge
Duke University
rongge@cs.duke.edu
Jason D. Lee
Princeton University
jasonlee@princeton.edu
Abstract
We focus on the task of learning a single index model σ(w⋆· x) with respect to
the isotropic Gaussian distribution in d dimensions. Prior work has shown that
the sample complexity of learning w⋆is governed by the information exponent k⋆
of the link function σ, which is defined as the index of the first nonzero Hermite
coefficient of σ. Ben Arous et al. [1] showed that n ≳dk⋆−1 samples suffice for
learning w⋆and that this is tight for online SGD. However, the CSQ lower bound
for gradient based methods only shows that n ≳dk⋆/2 samples are necessary. In
this work, we close the gap between the upper and lower bounds by showing that
online SGD on a smoothed loss learns w⋆with n ≳dk⋆/2 samples. We also draw
connections to statistical analyses of tensor PCA and to the implicit regularization
effects of minibatch SGD on empirical losses.
1
Introduction
Gradient descent-based algorithms are popular for deriving computational and statistical guarantees
for a number of high-dimensional statistical learning problems [2, 3, 1, 4–6]. Despite the fact that
the empirical loss is nonconvex and in the worst case computationally intractible to optimize, for
a number of statistical learning tasks gradient-based methods still converge to good solutions with
polynomial runtime and sample complexity. Analyses in these settings typically study properties of
the empirical loss landscape [7], and in particular the number of samples needed for the signal of the
gradient arising from the population loss to overpower the noise in some uniform sense. The sample
complexity for learning with gradient descent is determined by the landscape of the empirical loss.
One setting in which the empirical loss landscape showcases rich behavior is that of learning a
single-index model. Single index models are target functions of the form f ∗(x) = σ(w⋆· x), where
w⋆∈Sd−1 is the unknown relevant direction and σ is the known link function. When the covariates
are drawn from the standard d-dimensional Gaussian distribution, the shape of the loss landscape is
governed by the information exponent k⋆of the link function σ, which characterizes the curvature of
the loss landscape around the origin. Ben Arous et al. [1] show that online stochastic gradient descent
on the empirical loss can recover w∗with n ≳dmax(1,k⋆−1) samples; furthermore, they present a
lower bound showing that for a class of online SGD algorithms, dmax(1,k⋆−1) samples are indeed
necessary.
However, gradient descent can be suboptimal for various statistical learning problems, as it only relies
on local information in the loss landscape and is thus prone to getting stuck in local minima. For
learning a single index model, the Correlational Statistical Query (CSQ) lower bound only requires
37th Conference on Neural Information Processing Systems (NeurIPS 2023).

dmax(1,k⋆/2) samples to recover w⋆[6, 4], which is far fewer than the number of samples required by
online SGD. This gap between gradient-based methods and the CSQ lower bound is also present in
the Tensor PCA problem [8]; for recovering a rank 1 k-tensor in d dimensions, both gradient descent
and the power method require dmax(1,k−1) samples, whereas more sophisticated spectral algorithms
can match the computational lower bound of dmax(1,k/2) samples.
In light of the lower bound from [1], it seems hopeless for a gradient-based algorithm to match
the CSQ lower bound for learning single-index models. [1] considers the regime in which SGD
is simply a discretization of gradient flow, in which case the poor properties of the loss landscape
with insufficient samples imply a lower bound. However, recent work has shown that SGD is not
just a discretization to gradient flow, but rather that it has an additional implicit regularization effect.
Specifically, [9–11] show that over short periods of time, SGD converges to a quasi-stationary
distribution N(θ, λS) where θ is an initial reference point, S is a matrix depending on the Hessian
and the noise covariance and λ = η
B measures the strength of the noise where η is the learning rate
and B is the batch size. The resulting long term dynamics therefore follow the smoothed gradient
e∇L(θ) = Ez∼N(0,S)[∇L(θ + λz)] which has the effect of regularizing the trace of the Hessian.
This implicit regularization effect of minibatch SGD has been shown to drastically improve general-
ization and reduce the number of samples necessary for supervised learning tasks [12–14]. However,
the connection between the smoothed landscape and the resulting sample complexity is poorly
understood. Towards closing this gap, we consider directly smoothing the loss landscape in order
to efficiently learn single index models. Our main result, Theorem 1, shows that for k⋆> 2, online
SGD on the smoothed loss learns w⋆in n ≳dk⋆/2 samples, which matches the correlation statistical
query (CSQ) lower bound. This improves over the n ≳dk⋆−1 lower bound for online SGD on the
unsmoothed loss from Ben Arous et al. [1]. Key to our analysis is the observation that smoothing the
loss landscape boosts the signal-to-noise ratio in a region around the initialization, which allows the
iterates to avoid the poor local minima for the unsmoothed empirical loss. Our analysis is inspired by
the implicit regularization effect of minibatch SGD, along with the partial trace algorithm for Tensor
PCA which achieves the optimal dk/2 sample complexity for computationally efficient algorithms.
The outline of our paper is as follows. In Section 3 we formalize the specific statistical learning
setup, define the information exponent k⋆, and describe our algorithm. Section 4 contains our main
theorem, and Section 5 presents a heuristic derivation for how smoothing the loss landscape increases
the signal-to-noise ratio. We present empirical verification in Section 6, and in Section 7 we detail
connections to tensor PCA nad minibatch SGD.
2
Related Work
There is a rich literature on learning single index models. Kakade et al. [15] showed that gradient
descent can learn single index models when the link function is Lipschitz and monotonic and designed
an alternative algorithm to handle the case when the link function is unknown. Soltanolkotabi [16]
focused on learning single index models where the link function is ReLU(x) := max(0, x) which
has information exponent k⋆= 1. The phase-retrieval problem is a special case of the single index
model in which the link function is σ(x) = x2 or σ(x) = |x|; this corresponds to k⋆= 2, and solving
phase retrieval via gradient descent has been well studied [17–20]. Dudeja and Hsu [21] constructed
an algorithm which explicitly uses the harmonic structure of Hermite polynomials to identify the
information exponent. Ben Arous et al. [1] provided matching upper and lower bounds that show that
n ≳dmax(1,k⋆−1) samples are necessary and sufficient for online SGD to recover w⋆.
Going beyond gradient-based algorithms, Chen and Meka [22] provide an algorithm that can learn
polynomials of few relevant dimensions with n ≳d samples, including single index models with
polynomial link functions. Their estimator is based on the structure of the filtered PCA matrix
Ex,y[1|y|≥τxxT ], which relies on the heavy tails of polynomials. In particular, this upper bound
does not apply to bounded link functions. Furthermore, while their result achieves the information-
theoretically optimal d dependence it is not a CSQ algorithm, whereas our Algorithm 1 achieves the
optimal sample complexity over the class of CSQ algorithms (which contains gradient descent).
Recent work has also studied the ability of neural networks to learn single or multi-index models [5,
6, 23, 24, 4]. Bietti et al. [5] showed that two layer neural networks are able to adapt to unknown link
functions with n ≳dk⋆samples. Damian et al. [6] consider multi-index models with polynomial
2

link function, and under a nondegeneracy assumption which corresponds to the k⋆= 2 case, show
that SGD on a two-layer neural network requires n ≳d2 + rp samples. Abbe et al. [24, 4] provide a
generalization of the information exponent called the leap. They prove that in some settings, SGD
can learn low dimensional target functions with n ≳dLeap−1 samples. However, they conjecture that
the optimal rate is n ≳dLeap/2 and that this can be achieved by ERM rather than online SGD.
The problem of learning single index models with information exponent k is strongly related to the
order k Tensor PCA problem (see Section 7.1), which was introduced by Richard and Montanari [8].
They conjectured the existence of a computational-statistical gap for Tensor PCA as the information-
theoretic threshold for the problem is n ≳d, but all known computationally efficient algorithms
require n ≳dk/2. Furthermore, simple iterative estimators including tensor power method, gradient
descent, and AMP are suboptimal and require n ≳dk−1 samples. Hopkins et al. [25] introduced the
partial trace estimator which succeeds with n ≳d⌈k/2⌉samples. Anandkumar et al. [26] extended this
result to show that gradient descent on a smoothed landscape could achieve dk/2 sample complexity
when k = 3 and Biroli et al. [27] heuristically extended this result to larger k. The success of
smoothing the landscape for Tensor PCA is one of the inspirations for Algorithm 1.
3
Setting
3.1
Data distribution and target function
Our goal is to efficiently learn single index models of the form f ⋆(x) = σ(w⋆· x) where w⋆∈Sd−1,
the d-dimensional unit sphere. We assume that σ is normalized so that Ex∼N(0,1)[σ(x)2] = 1. We
will also assume that σ is differentiable and that σ′ has polynomial tails:
Assumption 1. There exist constants C1, C2 such that |σ′(x)| ≤C1(1 + x2)C2.
Our goal is to recover w⋆given n samples (x1, y1), . . . , (xn, yn) sampled i.i.d from
xi ∼N(0, Id),
yi = f ⋆(xi) + zi
where
zi ∼N(0, ς2).
For simplicity of exposition, we assume that σ is known and we take our model class to be
f(w, x) := σ(w · x)
where
w ∈Sd−1.
3.2
Algorithm: online SGD on a smoothed landscape
As w ∈Sd−1 we will let ∇w denote the spherical gradient with respect to w. That is, for a function
g : Rd →R, let ∇wg(w) = (I −wwT )∇g(z)

z=w where ∇is the standard Euclidean gradient.
To compute the loss on a sample (x, y), we use the correlation loss:
L(w; x; y) := 1 −f(w, x)y.
Furthermore, when the sample is omitted we refer to the population loss:
L(w) := Ex,y[L(w; x; y)]
Our primary contribution is that SGD on a smoothed loss achieves the optimal sample complexity for
this problem. First, we define the smoothing operator Lλ:
Definition 1. Let g : Sd−1 →R. We define the smoothing operator Lλ by
(Lλg)(w) := Ez∼µw

g
 w + λz
∥w + λz∥

where µw is the uniform distribution over Sd−1 conditioned on being perpendicular to w.
This choice of smoothing is natural for spherical gradient descent and can be directly related1 to the
Riemannian exponential map on Sd−1. We will often abuse notation and write Lλ(g(w)) rather than
(Lλg)(w). The smoothed empirical loss Lλ(w; x; y) and the population loss Lλ(w) are defined by:
Lλ(w; x; y) := Lλ(L(w; x; y))
and
Lλ(w) := Lλ(L(w)).
1This is equivalent to the intrinsic definition (Lλg)(w) := Ez∼UTw(Sd−1)[expw(θz)] where θ = arctan(λ),
UTw(Sd−1) is the unit sphere in the tangent space Tw(Sd−1), and exp is the Riemannian exponential map.
3

Our algorithm is online SGD on the smoothed loss Lλ:
Algorithm 1: Smoothed Online SGD
Input: learning rate schedule {ηt}, smoothing schedule {λt}, steps T
Sample w0 ∼Unif(Sd−1)
for t = 0 to T −1 do
Sample a fresh sample (xt, yt)
ˆwt+1 ←wt −ηt∇wLλt(wt; xt; yt)
wt+1 ←ˆwt+1/∥ˆwt+1∥
end
3.3
Hermite polynomials and information exponent
The sample complexity of Algorithm 1 depends on the Hermite coefficients of σ:
Definition 2 (Hermite Polynomials). The kth Hermite polynomial Hek : R →R is the degree k,
monic polynomial defined by
Hek(x) = (−1)k ∇kµ(x)
µ(x) ,
where µ(x) := e−x2
2
√
2π is the PDF of a standard Gaussian.
The first few Hermite polynomials are He0(x) = 1, He1(x) = x, He2(x) = x2 −1, He3(x) =
x3−3x. For further discussion on the Hermite polynomials and their properties, refer to Appendix A.2.
The Hermite polynomials form an orthogonal basis of L2(µ) so any function in L2(µ) admits a
Hermite expansion. We let {ck}k≥0 denote the Hermite coefficients of the link function σ:
Definition 3 (Hermite Expansion of σ). Let {ck}k≥0 be the Hermite coefficients of σ, i.e.
σ(x) =
X
k≥0
ck
k! Hek(x)
where
ck = Ex∼N(0,1)[σ(x)Hek(x)].
The critical quantity of interest is the information exponent of σ:
Definition 4 (Information Exponent). k⋆= k⋆(σ) is the first index k ≥1 such that ck ̸= 0.
Example 1. Below are some example link functions and their information exponents:
• σ(x) = x and σ(x) = ReLU(x) := max(0, x) have information exponents k⋆= 1.
• σ(x) = x2 and σ(x) = |x| have information exponents k⋆= 2.
• σ(x) = x3 −3x has information exponent k⋆= 3. More generally, σ(x) = Hek(x) has
information exponent k⋆= k.
Throughout our main results we focus on the case k⋆≥3 as when k⋆= 1, 2, online SGD without
smoothing already achieves the optimal sample complexity of n ≍d samples (up to log factors) [1].
4
Main Results
Our main result is a sample complexity guarantee for Algorithm 1:
Theorem 1. Assume w0 ·w⋆≳d−1/2 and λ ∈[1, d1/4]. Then there exists a choice of T1, η satisfying
T1 = ˜O
 dk⋆−1λ−2k⋆+4
and η = ˜O(d−k⋆/2λ2k⋆−2) such that if we run Algorithm 1 with λt = λ
and ηt = η for t ≤T1 and λt = 0 and ηt = O
 (d + t −T1)−1
for t > T1, we have that with high
probability, after T = T1 + T2 steps, the final iterate wT satisfies L(wT ) ≤O(
d
d+T2 ).
Note that the condition that w0 · w⋆≳d1/2 can be guaranteed with probability 1/2. Theorem 1 uses
large smoothing (up to λ = d1/4) to rapidly escape the regime in which w · w⋆≍d−1/2. This first
stage continues until w · w⋆= 1 −od(1) which takes T1 = ˜O(dk⋆/2) steps when λ = d1/4. The
second stage, in which λ = 0 and the learning rate decays linearly, lasts for an additional T2 = d/ϵ
4

steps where ϵ is the target accuracy. Because Algorithm 1 uses each sample exactly once, this gives
the sample complexity
n ≳dk⋆−1λ−2k⋆+4 + d/ϵ
to reach population loss L(wT ) ≤ϵ. Setting λ = O(1) is equivalent to zero smoothing and gives a
sample complexity of n ≳dk⋆−1 + d/ϵ, which matches the results of Ben Arous et al. [1]. On the
other hand, setting λ to the maximal allowable value of d1/4 gives:
n ≳
d
k⋆
2
|{z}
CSQ
lower bound
+
d/ϵ
|{z}
information
lower bound
which matches the sum of the CSQ lower bound, which is d
k⋆
2 , and the information-theoretic lower
bound, which is d/ϵ, up to poly-logarithmic factors.
To complement Theorem 1, we replicate the CSQ lower bound in [6] for the specific function
class σ(w · x) where w ∈Sd−1. Statistical query learners are a family of learners that can query
values q(x, y) and receive outputs ˆq with |ˆq −Ex,y[q(x, y)]| ≤τ where τ denotes the query tolerance
[28, 29]. An important class of statistical query learners is that of correlational/inner product statistical
queries (CSQ) of the form q(x, y) = yh(x). This includes a wide class of algorithms including
gradient descent with square loss and correlation loss. For example, if the model is fθ(x), then the
gradient with square loss can be written as
∇L(w; x, y) = (fθ(x) −y)∇fθ(x)
|
{z
}
query
.
Note that the other term in the gradient only depends on the distribution of x ∼N(0, Id) which
we assume is known. However, this connection with gradient descent is only heuristic as the errors
in GD are random while the errors in the SQ/CSQ framework are adversarial. However, SQ/CSQ
lower bounds are frequently used to argue the existence of statistical-computational gaps in statistical
learning problems [30–33]. Theorem 2 measures the tolerance needed by CSQ learners to learn w⋆.
Theorem 2 (CSQ Lower Bound). Consider the function class Fσ := {σ(w · x) : w ∈Sd−1}. Any
CSQ algorithm using q queries requires a tolerance τ of at most
τ ≲
log(qd)
d
k⋆/4
to output an f ∈Fσ with population loss less than 1/2.
Using the standard τ ≈n−1/2 heuristic which comes from concentration, this implies that n ≳d
k⋆
2
samples are necessary to learn σ(w · x) unless the algorithm makes exponentially many queries. In
the context of gradient descent, this is equivalent to either requiring exponentially many parameters
or exponentially many steps of gradient descent.
5
Proof Sketch
In this section we highlight the key ideas of the proof of Theorem 1. The full proof is deferred to
Appendix B. The proof sketch is broken into three parts. First, we conduct a general analysis on
online SGD to show how the signal-to-noise ratio (SNR) affects the sample complexity. Next, we
compute the SNR for the unsmoothed objective (λ = 0) to heuristically rederive the dk⋆−1 sample
complexity in Ben Arous et al. [1]. Finally, we show how smoothing boosts the SNR and leads to an
improved sample complexity of dk⋆/2 when λ = d1/4.
5.1
Online SGD Analysis
To begin, we will analyze a single step of online SGD. We define αt := wt · w⋆so that αt ∈[−1, 1]
measures our current progress. Furthermore, let vt := −∇Lλt(wt; xt; yt). Recall that the online
SGD update is:
wt+1 =
wt + ηtvt
∥wt + ηtvt∥=⇒αt+1 = αt + ηt(vt · w⋆)
∥wt + ηtvt∥
.
5

Using the fact that vt ⊥wt and
1
√
1+x2 ≈1 −x2
2 we can Taylor expand the update for αt+1:
αt+1 = αt + ηt(vt · w⋆)
q
1 + η2
t ∥vt∥2 ≈αt + ηt(vt · w⋆) −η2
t ∥vt∥2αt
2
+ h.o.t.
As in Ben Arous et al. [1], we decompose this update into a drift term and a martingale term. Let
Ft = σ{(x0, y0), . . . , (xt−1, yt−1)} be the natural filtration. We focus on the drift term as the
martingale term can be handled with standard concentration arguments. Taking expectations with
respect to the fresh batch (xt, yt) gives:
E[αt+1|Ft] ≈αt + ηt E[vt · w⋆|Ft] −η2
t E[∥vt∥2|Ft]αt/2
so to guarantee a positive drift, we need to set ηt ≤
2 E[vt·w⋆|Ft]
E[∥vt∥2|Ft]αt which gives us the value of ηt
used in Theorem 1 for t ≤T1. However, to simplify the proof sketch we can assume knowledge of
E[vt · w⋆|Ft] and E[∥vt∥2|Ft] and optimize over ηt to get a maximum drift of
E[αt+1|wt] ≈αt +
1
2αt
· E[vt · w⋆|Ft]2
E[∥vt∥2|Ft]
|
{z
}
SNR
.
The numerator measures the correlation of the population gradient with w⋆while the denominator
measures the norm of the noisy gradient. Their ratio thus has a natural interpretation as the signal-
to-noise ratio (SNR). Note that the SNR is a local property, i.e. the SNR can vary for different wt.
When the SNR can be written as a function of αt = wt · w⋆, the SNR directly dictates the rate of
optimization through the ODE approximation: α′ ≈SNR/α. As online SGD uses each sample
exactly once, the sample complexity for online SGD can be approximated by the time it takes this
ODE to reach α ≈1 from α0 ≈d−1/2. The remainder of the proof sketch will therefore focus on
analyzing the SNR of the minibatch gradient ∇Lλ(w; x; y).
5.2
Computing the Rate with Zero Smoothing
When λ = 0, the signal and noise terms can easily be calculated. The key property we need is:
Property 1 (Orthogonality Property). Let w, w⋆∈Sd−1 and let α = w · w⋆. Then:
Ex∼N(0,Id)[Hej(w · x)Hek(w⋆· x)] = δjkk!αk.
Using Property 1 and the Hermite expansion of σ (Definition 3) we can directly compute the
population loss and gradient. Letting P ⊥
w := I −wwT denote the projection onto the subspace
orthogonal to w we have:
L(w) =
X
k≥0
c2
k
k! [1 −αk]
and
∇L(w) = −(P ⊥
w w⋆)
X
k≥0
c2
k
(k −1)!αk−1.
As α ≪1 throughout most of the trajectory, the gradient is dominated by the first nonzero Hermite
coefficient so up to constants: E[v·w⋆] = −∇L(w)·w⋆≈αk⋆−1. Similarly, a standard concentration
argument shows that because v is a random vector in d dimensions where each coordinate is O(1),
E[∥v∥]2 ≈d. Therefore the SNR is equal to α2(k⋆−1)/d so with an optimal learning rate schedule,
E[αt+1|Ft] ≈αt + α2k⋆−3
t
/d.
This can be approximated by the ODE α′ = α2k⋆−3/d. Solving this ODE with the initial α0 ≍d−1/2
gives that the escape time is proportional to dα−2(k⋆−1)
0
= dk⋆−1 which heuristically re-derives the
result of Ben Arous et al. [1].
5.3
How Smoothing boosts the SNR
Smoothing improves the sample complexity of online SGD by boosting the SNR of the stochastic
gradient ∇L(w; x; y).
6

d−1/2
d−1/4
1
d−k⋆
d−k
2 +1
d−k
2 + 1
2
1
α
SNR
SNR with λ = d1/4
k⋆odd
k⋆even
No Smoothing
Figure 1: When λ = d1/4, smoothing increases the SNR until α = λd−1/2 = d−1/4.
Computing the Signal
Recall that the population loss was approximately equal to 1 −c2
k⋆
k⋆! αk⋆
where k⋆is the first nonzero Hermite coefficient of σ. Isolating the dominant αk⋆term and applying
the smoothing operator Lλ, we get:
Lλ(αk⋆) = Ez∼µw
" w + λz
∥w + λz∥· w⋆
k⋆#
.
Because z ⊥w and ∥z∥= 1 we have that ∥w + λz∥=
√
1 + λ2 ≈λ. Therefore,
Lλ(αk⋆) ≈λ−k⋆Ez∼µw
h
(α + λ(z · w⋆))k⋆i
= λ−k⋆
k
X
j=0
k⋆
j

αk⋆−jλj Ez∼µw[(z · w⋆)j].
Now because z
d= −z, the terms where j is odd disappear. Furthermore, for a random z, |z · w⋆| =
Θ(d−1/2). Therefore reindexing and ignoring all constants we have that
Lλ(w) ≈1 −Lλ(αk⋆) ≈1 −λ−k⋆
⌊k⋆
2 ⌋
X
j=0
αk⋆−2j λ2/d
j.
Differentiating gives that
E[v · w⋆] ≈−w⋆· ∇wLλ(αk⋆) ≈λ−1
⌊k⋆−1
2
⌋
X
j=0
α
λ
k⋆−1 λ2
α2d
j
.
As this is a geometric series, it is either dominated by the first or the last term depending on whether
α ≥λd−1/2 or α ≤λd−1/2. Furthermore, the last term is either d−k⋆−1
2
if k⋆is odd or α
λd−k⋆−2
2
if
k⋆is even. Therefore the signal term is:
E[v · w⋆] ≈λ−1





( α
λ)k⋆−1
α ≥λd−1/2
d−k⋆−1
2
α ≤λd−1/2 and k⋆is odd
α
λd−k⋆−2
2
α ≤λd−1/2 and k⋆is even
.
Computing the Noise
Recall that Lλ(w; x, y) = 1 −yσ(w · x). Differentiating through the
smoothing operator gives:
∇wLλ(w; x, y) = −y∇w Lλ(σ(w · x)) ≈λ−1yxLλ(σ′(w · x)).
We know that with high probability, y = ˜O(1) and ∥x∥= O(
√
d) so it suffices to bound Lλ(σ′(w·x)).
The variance of this term is equal to:
Ex[Lλ(σ′(w · x))2] = Ex
"
Ez∼µw

σ′
 w + λz
√
1 + λ2 · x
2#
.
To compute this expectation, we will create an i.i.d. copy z′ of z and rewrite this expectation as:
Ex[Lλ(σ′(w · x))2] = Ex

Ez,z′∼µw

σ′
 w + λz
√
1 + λ2 · x

σ′
 w + λz′
√
1 + λ2 · x

.
7

Now we can swap the expectations and compute the expectation with respect to x first using the
Hermite expansion of σ. As the first nonzero Hermite coefficient of σ′ is k⋆−1, this variance is
approximately equal to the correlation between
w+λz
√
1+λ2 and w+λz′
√
1+λ2 raised to the k⋆−1 power:
Ex[Lλ(σ′(w · x))2] ≈Ez,z′∼µw
" w + λz
√
1 + λ2 · w + λz′
√
1 + λ2
k⋆−1#
= Ez,z′∼µw
"1 + λ2z · z′
1 + λ2
k⋆−1#
As z, z′ are random unit vectors, their inner product is of order d−1/2. Therefore when λ ≪d1/4, the
first term in the numerator is dominant and when λ ≫d1/4, the second term is dominant. Combining
these two regimes gives that the variance is of order min(λ, d1/4)k⋆−1 which motivates our choice of
λ = d1/4. Combining this with y = ˜O(1) and ∥x∥= O(
√
d) gives that for λ ≤d1/4, the variance
of the noise is bounded by E[∥v∥2] ≲dλ−2k⋆. Note that in the high signal regime (α ≥λd−1/2),
both the signal and the noise are smaller by factors of λk⋆which cancel when computing the SNR.
However, when α ≤λd−1/2 the smoothing shrinks the noise faster than it shrinks the signal, resulting
in an overall larger SNR. Explicitly,
SNR := E[v · w⋆]2
E[∥v∥2]
≈1
d



α2(k⋆−1)
α ≥λd−1/2
(λ2/d)k⋆−1
α ≤λd−1/2 and k⋆is odd
α2(λ2/d)k⋆−2
α ≤λd−1/2 and k⋆is even
.
For α ≥λd−1/2, smoothing does not affect the SNR. However, when α ≤λd−1/2, smoothing
greatly increases the SNR (see Figure 1).
Solving the ODE: α′ = SNR/α gives that it takes T ≈dk⋆−1λ−2k⋆+4 steps to converge to α ≈1
from α ≈d−1/2. Once α ≈1, the problem is locally strongly convex, so we can decay the learning
rate and use classical analysis of strongly-convex functions to show that α ≥1 −ϵ with an additional
d/ϵ steps, from which Theorem 1 follows.
6
Experiments
For k⋆= 3, 4, 5 and d = 28, . . . , 213 we ran a minibatch variant of Algorithm 1 with batch size B
when σ(x) = Hek⋆(x)
√
k!
, the normalized k⋆th Hermite polynomial. We set:
λ = d1/4,
η = Bd−k⋆/2(1 + λ2)k⋆−1
1000k⋆!
,
B = min

0.1dk⋆/2(1 + λ2)−2k⋆+4, 8192

.
We computed the number of samples required for Algorithm 1 to reach α2 = 0.5 from α = d−1/2
and we report the min, mean, and max over 10 random seeds. For each k we fit a power law of the
form n = c1dc2 in order to measure how the sample complexity scales with d. For all values of
k⋆, we find that c2 ≈k⋆/2 which matches Theorem 1. The results can be found in Figure 2 and
additional experimental details can be found in Appendix E.
7
Discussion
7.1
Tensor PCA
We next outline connections to the Tensor PCA problem. Introduced in [8], the goal of Tensor PCA
is to recover the hidden direction w∗∈Sd−1 from the noisy k-tensor Tn ∈(Rd)⊗k given by2
Tn = (w∗)⊗k +
1
√nZ,
where Z ∈(Rd)⊗k is a Gaussian noise tensor with each entry drawn i.i.d from N(0, 1).
The Tensor PCA problem has garnered significant interest as it exhibits a statistical-computational
gap. w∗is information theoretically recoverable when n ≳d. However, the best polynomial-time
algorithms require n ≳dk/2; this lower bound has been shown to be tight for various notions of
2This normalization is equivalent to the original
1
β
√
dZ normalization by setting n = β2d.
8

28
29
210
211
212
213
d (input dimension)
219
221
223
225
227
229
231
n (sample complexity)
Online SGD Sample Complexity, λ = d1/4
k⋆= 3, best ﬁt: n ∝d1.5
k⋆= 4, best ﬁt: n ∝d2.1
k⋆= 5, best ﬁt: n ∝d2.5
Figure 2: For k⋆= 3, 4, 5, Algorithm 1 finds w⋆with n ∝dk⋆/2 samples. The solid lines and the
shaded areas represent the mean and min/max values over 10 random seeds. For each curve, we also
fit a power law n = c1dc2 represented by the dashed lines. The value of c2 is reported in the legend.
hardness such as CSQ or SoS lower bounds [34, 25, 35–39]. Tensor PCA also exhibits a gap between
spectral methods and iterative algorithms. Algorithms that work in the n ≍dk/2 regime rely on
unfolding or contracting the tensor X, or on semidefinite programming relaxations [34, 25]. On
the other hand, iterative algorithms including gradient descent, power method, and AMP require
a much larger sample complexity of n ≳dk−1 [40]. The suboptimality of iterative algorithms is
believed to be due to bad properties of the landscape of the Tensor PCA objective in the region around
the initialization. Specifically [41, 42] argue that there are exponentially many local minima near
the equator in the n ≪dk−1 regime. To overcome this, prior works have considered “smoothed"
versions of gradient descent, and show that smoothing recovers the computationally optimal SNR in
the k = 3 case [26] and heuristically for larger k [27].
7.1.1
The Partial Trace Algorithm
The smoothing algorithms above are inspired by the following partial trace algorithm for Tensor PCA
[25], which can be viewed as Algorithm 1 in the limit as λ →∞[26]. Let Tn = (w⋆)⊗k +
1
√nZ.
Then we will consider iteratively contracting indices of T until all that remains is a vector (if k is
odd) or a matrix (if k is even). Explicitly, we define the partial trace tensor by
Mn := Tn

I
⊗⌈k−2
2
⌉
d

∈
Rd×d
k is even
Rd
k is odd.
When k⋆is odd, we can directly return Mn as our estimate for w⋆and when k⋆is even we return the
top eigenvector of Mn. A standard concentration argument shows that this succeeds when n ≳d⌈k/2⌉.
Furthermore, this can be strengthened to dk/2 by using the partial trace vector as a warm start for
gradient descent or tensor power method when k is odd [26, 27].
7.1.2
The Connection Between Single Index Models and Tensor PCA
For both tensor PCA and learning single index models, gradient descent succeeds when the sample
complexity is n = dk−1 [40, 1]. On the other hand, the smoothing algorithms for Tensor PCA
[27, 26] succeed with the computationally optimal sample complexity of n = dk/2. Our Theorem 1
shows that this smoothing analysis can indeed be transferred to the single-index model setting.
In fact, one can make a direct connection between learning single-index models with Gaussian
covariates and Tensor PCA. Consider learning a single-index model when σ(x) =
Hek(x)
√
k! , the
normalized kth Hermite polynomial. Then minimizing the correlation loss is equivalent to maximizing
9

the loss function:
Ln(w) = 1
n
n
X
i=1
yi
Hek(w · xi)
√
k!
=

w⊗k, Tn

where
Tn := 1
n
n
X
i=1
yi
Hek(xi)
√
k!
.
Here Hek(xi) ∈(Rd)⊗k denotes the kth Hermite tensor (see Appendix A.2 for background on
Hermite polynomials and Hermite tensors). In addition, by the orthogonality of the Hermite tensors,
Ex,y[Tn] = (w⋆)⊗k so we can decompose Tn = (w⋆)⊗k + Zn where by standard concentration,
each entry of Zn is order n−1/2. We can therefore directly apply algorithms for Tensor PCA to this
problem. We remark that this connection is a heuristic, as the structure of the noise in Tensor PCA
and our single index model setting are different.
7.2
Empirical Risk Minimization on the Smoothed Landscape
Our main sample complexity guarantee, Theorem 1, is based on a tight analysis of online SGD
(Algorithm 1) in which each sample is used exactly once. One might expect that if the algorithm were
allowed to reuse samples, as is standard practice in deep learning, that the algorithm could succeed
with fewer samples. In particular, Abbe et al. [4] conjectured that gradient descent on the empirical
loss Ln(w) := 1
n
Pn
i=1 L(w; xi; yi) would succeed with n ≳dk⋆/2 samples.
Our smoothing algorithm Algorithm 1 can be directly translated to the ERM setting to learn w⋆with
n ≳dk⋆/2 samples. We can then Taylor expand the smoothed loss in the large λ limit:
Lλ(Ln(w)) ≈Ez∼Unif(Sd−1)

Ln(z) + λ−1w · ∇Ln(z) + λ−2
2
· wT ∇2Ln(z)w

+ O(λ−3).
As λ →∞, gradient descent on this smoothed loss will converge to Ez∼Unif(Sd−1)[∇Ln(z)] which is
equivalent to the partial trace estimator for k⋆odd (see Section 7.1). If k⋆is even, this first term is zero
in expectation and gradient descent will converge to the top eigenvector of Ez∼Unif(Sd−1)[∇2Ln(z)],
which corresponds to the partial trace estimator for k⋆even. Mirroring the calculation for the partial
trace estimator, this succeeds with n ≳d⌈k⋆/2⌉samples. When k⋆is odd, this can be further improved
to dk⋆/2 by using this estimator as a warm start from which to run gradient descent with λ = 0 as in
Anandkumar et al. [26], Biroli et al. [27].
7.3
Connection to Minibatch SGD
A recent line of works has studied the implicit regularization effect of stochastic gradient descent
[9, 11, 10]. The key idea is that over short timescales, the iterates converge to a quasi-stationary
distribution N(θ, λS) where S ≈I depends on the Hessian and the noise covariance at θ and λ is
proportional to the ratio of the learning rate and batch size. As a result, over longer periods of time
SGD follows the smoothed gradient of the empirical loss:
eLn(w) = Ez∼N(0,S)[Ln(w + λz)].
We therefore conjecture that minibatch SGD is also able to achieve the optimal n ≳dk⋆/2 sample
complexity without explicit smoothing if the learning rate and batch size are properly tuned.
Acknowledgments and Disclosure of Funding
AD acknowledges support from a NSF Graduate Research Fellowship. EN acknowledges support
from a National Defense Science & Engineering Graduate Fellowship. RG is supported by NSF
Award DMS-2031849, CCF-1845171 (CAREER), CCF-1934964 (Tripods) and a Sloan Research
Fellowship. AD, EN, and JDL acknowledge support of the ARO under MURI Award W911NF-11-
1-0304, the Sloan Research Fellowship, NSF CCF 2002272, NSF IIS 2107304, NSF CIF 2212262,
ONR Young Investigator Award, and NSF CAREER Award 2144994.
References
[1] Gerard Ben Arous, Reza Gheissari, and Aukosh Jagannath. Online stochastic gradient descent
on non-convex losses from high-dimensional inference. The Journal of Machine Learning
Research, 22(1):4788–4838, 2021.
10

[2] Rong Ge, Jason D Lee, and Tengyu Ma. Matrix completion has no spurious local minimum.
Advances in neural information processing systems, 29, 2016.
[3] Tengyu Ma. Why do local methods solve nonconvex problems?, 2020.
[4] Emmanuel Abbe, Enric Boix-Adserà, and Theodor Misiakiewicz. Sgd learning on neural
networks: leap complexity and saddle-to-saddle dynamics. arXiv, 2023. URL https://
arxiv.org/abs/2302.11055.
[5] Alberto Bietti, Joan Bruna, Clayton Sanford, and Min Jae Song. Learning single-index models
with shallow neural networks. In Advances in Neural Information Processing Systems (NeurIPS),
2022.
[6] Alexandru Damian, Jason Lee, and Mahdi Soltanolkotabi. Neural networks can learn represen-
tations with gradient descent. In Conference on Learning Theory, pages 5413–5452. PMLR,
2022.
[7] Song Mei, Yu Bai, and Andrea Montanari. The landscape of empirical risk for nonconvex losses.
The Annals of Statistics, 46:2747–2774, 2018.
[8] Emile Richard and Andrea Montanari. A statistical model for tensor pca. In Advances in Neural
Information Processing Systems, pages 2897 – 2905, 2014.
[9] Guy Blanc, Neha Gupta, Gregory Valiant, and Paul Valiant. Implicit regularization for deep
neural networks driven by an ornstein-uhlenbeck like process. In Conference on Learning
Theory, pages 483–513, 2020.
[10] Alex Damian, Tengyu Ma, and Jason D. Lee. Label noise SGD provably prefers flat global
minimizers. In A. Beygelzimer, Y. Dauphin, P. Liang, and J. Wortman Vaughan, editors,
Advances in Neural Information Processing Systems, 2021.
[11] Zhiyuan Li, Tianhao Wang, and Sanjeev Arora. What happens after SGD reaches zero loss? –a
mathematical framework. In International Conference on Learning Representations, 2022.
[12] Christopher J Shallue, Jaehoon Lee, Joseph Antognini, Jascha Sohl-Dickstein, Roy Frostig, and
George E Dahl. Measuring the effects of data parallelism on neural network training. arXiv
preprint arXiv:1811.03600, 2018.
[13] Christian Szegedy, Vincent Vanhoucke, Sergey Ioffe, Jon Shlens, and Zbigniew Wojna. Re-
thinking the inception architecture for computer vision. In Proceedings of the IEEE conference
on computer vision and pattern recognition, pages 2818–2826, 2016.
[14] Yeming Wen, Kevin Luk, Maxime Gazeau, Guodong Zhang, Harris Chan, and Jimmy Ba.
Interplay between optimization and generalization of stochastic gradient descent with covariance
noise. arXiv preprint arXiv:1902.08234, 2019.
[15] Sham M Kakade, Varun Kanade, Ohad Shamir, and Adam Kalai. Efficient learning of general-
ized linear and single index models with isotonic regression. Advances in Neural Information
Processing Systems, 24, 2011.
[16] Mahdi Soltanolkotabi. Learning relus via gradient descent. In Advances in Neural Information
Processing Systems (NeurIPS), 2017.
[17] Emmanuel J. Candès, Xiaodong Li, and Mahdi Soltanolkotabi. Phase retrieval via wirtinger
flow: Theory and algorithms. IEEE Transactions on Information Theory, 61(4):1985–2007,
2015. doi: 10.1109/TIT.2015.2399924.
[18] Yuxin Chen, Yuejie Chi, Jianqing Fan, and Cong Ma. Gradient descent with random initializa-
tion: fast global convergence for nonconvex phase retrieval. Mathematical Programming, 176
(1):5–37, 2019.
[19] Ju Sun, Qing Qu, and John Wright. A geometric analysis of phase retrieval. Foundations of
Computational Mathematics, 18(5):1131001198, 2018.
11

[20] Yan Shuo Tan and Roman Vershynin. Online stochastic gradient descent with arbitrary initial-
ization solves non-smooth, non-convex phase retrieval, 2019.
[21] Rishabh Dudeja and Daniel Hsu. Learning single-index models in gaussian space. In Sébastien
Bubeck, Vianney Perchet, and Philippe Rigollet, editors, Proceedings of the 31st Confer-
ence On Learning Theory, volume 75 of Proceedings of Machine Learning Research, pages
1887–1930. PMLR, 06–09 Jul 2018. URL https://proceedings.mlr.press/v75/
dudeja18a.html.
[22] Sitan Chen and Raghu Meka. Learning polynomials in few relevant dimensions. In Jacob
Abernethy and Shivani Agarwal, editors, Proceedings of Thirty Third Conference on Learning
Theory, volume 125 of Proceedings of Machine Learning Research, pages 1161–1227. PMLR,
09–12 Jul 2020. URL https://proceedings.mlr.press/v125/chen20a.html.
[23] Jimmy Ba, Murat A. Erdogdu, Taiji Suzuki, Zhichao Wang, Denny Wu, and Greg Yang. High-
dimensional asymptotics of feature learning: How one gradient step improves the representation.
In Advances in Neural Information Processing Systems (NeurIPS), 2022.
[24] Emmanuel Abbe, Enric Boix Adsera, and Theodor Misiakiewicz. The merged-staircase property:
a necessary and nearly sufficient condition for sgd learning of sparse functions on two-layer
neural networks. In Conference on Learning Theory, pages 4782–4887. PMLR, 2022.
[25] Samuel B. Hopkins, Tselil Schramm, Jonathan Shi, and David Steurer. Fast spectral algorithms
from sum-of-squares proofs: Tensor decomposition and planted sparse vectors. In Proceedings
of the Forty-Eighth Annual ACM Symposium on Theory of Computing, STOC ’16, page 178–191,
New York, NY, USA, 2016. Association for Computing Machinery. ISBN 9781450341325. doi:
10.1145/2897518.2897529. URL https://doi.org/10.1145/2897518.2897529.
[26] Anima Anandkumar, Yuan Deng, Rong Ge, and Hossein Mobahi. Homotopy analysis for tensor
pca. In Satyen Kale and Ohad Shamir, editors, Proceedings of the 2017 Conference on Learning
Theory, volume 65 of Proceedings of Machine Learning Research, pages 79–104. PMLR, 07–10
Jul 2017. URL https://proceedings.mlr.press/v65/anandkumar17a.html.
[27] Giulio Biroli, Chiara Cammarota, and Federico Ricci-Tersenghi. How to iron out rough
landscapes and get optimal performances: averaged gradient descent and its application to
tensor pca. Journal of Physics A: Mathematical and Theoretical, 53(17):174003, apr 2020.
doi: 10.1088/1751-8121/ab7b1f. URL https://dx.doi.org/10.1088/1751-8121/
ab7b1f.
[28] Surbhi Goel, Aravind Gollakota, Zhihan Jin, Sushrut Karmalkar, and Adam Klivans. Super-
polynomial lower bounds for learning one-layer neural networks using gradient descent. arXiv
preprint arXiv:2006.12011, 2020.
[29] Ilias Diakonikolas, Daniel M Kane, Vasilis Kontonis, and Nikos Zarifis. Algorithms and sq
lower bounds for pac learning one-hidden-layer relu networks. In Conference on Learning
Theory, pages 1514–1539, 2020.
[30] Vitaly Feldman, Elena Grigorescu, Lev Reyzin, Santosh Vempala, and Ying Xiao. Statistical
algorithms and a lower bound for detecting planted clique, 2016.
[31] Ilias Diakonikolas, Daniel M. Kane, and Alistair Stewart. Statistical query lower bounds for
robust estimation of high-dimensional gaussians and gaussian mixtures, 2017.
[32] Surbhi Goel, Aravind Gollakota, and Adam Klivans.
Statistical-query lower bounds via
functional gradients, 2020.
[33] Rishabh Dudeja and Daniel Hsu. Statistical query lower bounds for tensor pca, 2021.
[34] Samuel B. Hopkins, Jonathan Shi, and David Steurer. Tensor principal component analy-
sis via sum-of-square proofs. In Peter Grünwald, Elad Hazan, and Satyen Kale, editors,
Proceedings of The 28th Conference on Learning Theory, volume 40 of Proceedings of Ma-
chine Learning Research, pages 956–1006, Paris, France, 03–06 Jul 2015. PMLR. URL
https://proceedings.mlr.press/v40/Hopkins15.html.
12

[35] Dmitriy Kunisky, Alexander S. Wein, and Afonso S. Bandeira. Notes on computational hardness
of hypothesis testing: Predictions using the low-degree likelihood ratio, 2019.
[36] Afonso S Bandeira, Ahmed El Alaoui, Samuel Hopkins, Tselil Schramm, Alexander S Wein,
and Ilias Zadik. The franz-parisi criterion and computational trade-offs in high dimensional
statistics. In S. Koyejo, S. Mohamed, A. Agarwal, D. Belgrave, K. Cho, and A. Oh, editors,
Advances in Neural Information Processing Systems, volume 35, pages 33831–33844. Curran
Associates, Inc., 2022.
[37] Matthew S Brennan, Guy Bresler, Sam Hopkins, Jerry Li, and Tselil Schramm. Statistical
query algorithms and low degree tests are almost equivalent. In Mikhail Belkin and Samory
Kpotufe, editors, Proceedings of Thirty Fourth Conference on Learning Theory, volume 134 of
Proceedings of Machine Learning Research, pages 774–774. PMLR, 15–19 Aug 2021. URL
https://proceedings.mlr.press/v134/brennan21a.html.
[38] Rishabh Dudeja and Daniel Hsu. Statistical query lower bounds for tensor pca. Journal of
Machine Learning Research, 22(83):1–51, 2021. URL http://jmlr.org/papers/v22/
20-837.html.
[39] Rishabh Dudeja and Daniel Hsu. Statistical-computational trade-offs in tensor pca and related
problems via communication complexity, 2022.
[40] Gérard Ben Arous, Reza Gheissari, and Aukosh Jagannath. Algorithmic thresholds for tensor
PCA. The Annals of Probability, 48(4):2052 – 2087, 2020. doi: 10.1214/19-AOP1415. URL
https://doi.org/10.1214/19-AOP1415.
[41] Valentina Ros, Gerard Ben Arous, Giulio Biroli, and Chiara Cammarota. Complex energy
landscapes in spiked-tensor and simple glassy models: Ruggedness, arrangements of local
minima, and phase transitions. Phys. Rev. X, 9:011003, Jan 2019. doi: 10.1103/PhysRevX.9.
011003. URL https://link.aps.org/doi/10.1103/PhysRevX.9.011003.
[42] Gérard Ben Arous, Song Mei, Andrea Montanari, and Mihai Nica. The landscape of the spiked
tensor model. Communications on Pure and Applied Mathematics, 72(11):2282–2330, 2019.
doi: https://doi.org/10.1002/cpa.21861. URL https://onlinelibrary.wiley.com/
doi/abs/10.1002/cpa.21861.
[43] Balázs Szörényi. Characterizing statistical query learning: Simplified notions and proofs. In
ALT, 2009.
[44] Iosif Pinelis. Optimum Bounds for the Distributions of Martingales in Banach Spaces. The
Annals of Probability, 22(4):1679 – 1706, 1994. doi: 10.1214/aop/1176988477. URL https:
//doi.org/10.1214/aop/1176988477.
[45] James Bradbury, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal
Maclaurin, George Necula, Adam Paszke, Jake VanderPlas, Skye Wanderman-Milne, and
Qiao Zhang. JAX: composable transformations of Python+NumPy programs, 2018. URL
http://github.com/google/jax.
[46] Lukas Biewald. Experiment tracking with weights and biases, 2020. URL https://www.
wandb.com/. Software available from wandb.com.
A
Background and Notation
A.1
Tensor Notation
Throughout this section let T ∈(Rd)⊗k be a k-tensor.
Definition 5 (Tensor Action). For a j tensor A ∈(Rd)⊗j with j ≤k, we define the action T[A] of
T on A by
(T[A])i1,...,ik−j := Ti1,...,ikAik−j+1,...,ik ∈(Rd)⊗(k−j).
We will also use ⟨T, A⟩to denote T[A] = A[T] when A, T are both k tensors. Note that this
corresponds to the standard dot product after flattening A, T.
13

Definition 6 (Permutation/Transposition). Given a k-tensor T and a permutation π ∈Sk, we use
π(T) to denote the result of permuting the axes of T by the permutation π, i.e.
π(T)i1,...,ik := Tiπ(1),...,iπ(k).
Definition 7 (Symmetrization). We define Symk ∈(Rd)⊗2k by
(Symk)i1,...,ik,j1,...,jk = 1
k!
X
π∈Sk
δiπ(1),j1 · · · δiπ(k),jk
where Sk is the symmetric group on 1, . . . , k. Note that Symk acts on k tensors T by
(Symk[T])i1,...,ik = 1
k!
X
π∈Sk
π(T).
i.e. Symk[T] is the symmetrized version of T.
We will also overload notation and use Sym to denote the symmetrization operator, i.e. if T is a
k-tensor, Sym(T) := Symk[T].
Definition 8 (Symmetric Tensor Product). For a k tensor T and a j tensor A we define the symmetric
tensor product of T and A by
T e⊗A := Sym(T ⊗A).
Lemma 1. For any tensor T,
∥Sym(T)∥F ≤∥T∥F .
Proof.
∥Sym(T)∥F =

1
k!
X
π∈Sk
π(T)

F
≤1
k!
X
π∈Sk
∥π(T)∥F = ∥T∥F
because permuting the indices of T does not change the Frobenius norm.
We will use the following two lemmas for tensor moments of the Gaussian distribution and the
uniform distribution over the sphere:
Definition 9. For integers k, d > 0, define the quantity ν(d)
k
as
ν(d)
k
:= (2k −1)!!
k−1
Y
j=0
1
d + 2j = Θ(d−k).
Note that ν(d)
k
= Ez∼Unif(Sd−1)[z2k
1 ].
Lemma 2 (Tensorized Moments).
Ex∼N(0,Id)[x⊗2k] = (2k −1)!!I e⊗k
and
Ez∼Unif(Sd−1)[z⊗2k] = ν(d)
k I e⊗k.
Proof. For the Gaussian moment, see [6]. The spherical moment follows from the decomposition
x
d= zr where r ∼χ(d).
Lemma 3.
∥I e⊗j∥2
F = (ν(d)
j
)−1
Proof. By Lemma 2 we have
1 = Ez∼Unif(Sd−1)[∥z∥2j] = ⟨Ez∼Unif(Sd−1)[z2j], I e⊗j⟩= ν(d)
j
∥I e⊗j∥2
F .
14

A.2
Hermite Polynomials and Hermite Tensors
We provide a brief review of the properties of Hermite polynomials and Hermite tensors.
Definition 10. We define the kth Hermite polynomial Hek(x) by
Hek(x) := (−1)k ∇kµ(x)
µ(x)
where µ(x) := e−∥x∥2
2
(2π)d/2 is the PDF of a standard Gaussian in d dimensions. Note that when d = 1,
this definition reduces to the standard univariate Hermite polynomials.
We begin with the classical properties of the scalar Hermite polynomials:
Lemma 4 (Properties of Hermite Polynomials). When d = 1,
• Orthogonality:
Ex∼N(0,1)[Hej(x)Hek(x)] = k!δjk
• Derivatives:
d
dxHek(x) = kHek−1(x)
• Correlations: If x, y ∼N(0, 1) are correlated Gaussians with correlation α := E[xy],
Ex,y[Hej(x)Hek(y)] = k!δjkαk.
• Hermite Expansion: If f ∈L2(µ) where µ is the PDF of a standard Gaussian,
f(x)
L2(µ)
=
X
k≥0
ck
k! Hek(x)
where
ck = Ex∼N(0,1)[f(x)Hek(x)].
These properties also have tensor analogues:
Lemma 5 (Hermite Polynomials in Higher Dimensions).
• Relationship to Univariante Hermite Polynomials: If ∥w∥= 1,
Hek(w · x) =

Hek(x), w⊗k
• Orthogonality:
Ex∼N(0,Id) [Hej(x) ⊗Hek(x)] = δjkk! Symk
or equivalently, for any j tensor A and k tensor B:
Ex∼N(0,Id) [⟨Hej(x), A⟩⟨Hek(x), B⟩] = δjkk! ⟨Sym(A), Sym(B)⟩.
• Hermite Expansions: If f : Rd →R satisfies Ex∼N(0,Id)[f(x)2] < ∞,
f =
X
k≥0
1
k! ⟨Hek(x), Ck⟩
where
Ck = Ex∼N(0,Id)[f(x)Hek(x)].
B
Proof of Theorem 1
The proof of Theorem 1 is divided into four parts. First, Appendix B.1 introduces some notation that
will be used throughout the proof. Next, Appendix B.2 computes matching upper and lower bounds
for the gradient of the smoothed population loss. Similarly, Appendix B.3 concentrates the empirical
gradient of the smoothed loss. Finally, Appendix B.4 combines the bounds in Appendix B.2 and
Appendix B.3 with a standard online SGD analysis to arrive at the final rate.
15

B.1
Additional Notation
Throughout the proof we will assume that w ∈Sd−1 so that ∇w denotes the spherical gradient of w.
In particular, ∇wg(w) ⊥w for any g : Sd−1 →R. We will also use α to denote w · w⋆so that we
can write expressions such as:
∇wα = P ⊥
w w⋆= w⋆−αw.
We will use the following assumption on λ without reference throughout the proof:
Assumption 2. λ2 ≤d/C for a sufficiently large constant C.
We note that this is satisfied for the optimal choice of λ = d1/4.
We will use ˜O(·) to hide polylog(d) dependencies. Explicitly, X = ˜O(1) if there exists C1, C2 > 0
such that |X| ≤C1 log(d)C2. We will also use the following shorthand for denoting high probability
events:
Definition 11. We say an event E happens with high probability if for every k ≥0 there exists d(k)
such that for all d ≥d(k), P[E] ≥1 −d−k.
Note that high probability events are closed under polynomially sized union bounds. As an example,
if X ∼N(0, 1) then X ≤log(d) with high probability because
P[x > log(d)] ≤exp

−log(d)2/2

≪d−k
for sufficiently large d. In general, Lemma 24 shows that if X is mean zero and has polynomial tails,
i.e. there exists C such that E[Xp]1/p ≤pC, then X = ˜O(1) with high probability.
B.2
Computing the Smoothed Population Gradient
Recall that
σ(x)
L2(µ)
=
X
k≥0
ck
k! Hek(x)
where
ck := Ex∼N(0,1)[σ(x)Hek(x)].
In addition, because we assumed that Ex∼N(0,1)[σ(x)2] = 1 we have Parseval’s identity:
1 = Ex∼N(0,1)[σ(x)2] =
X
k≥0
c2
k
k! .
This Hermite decomposition immmediately implies a closed form for the population loss:
Lemma 6 (Population Loss). Let α = w · w⋆. Then,
L(w) =
X
k≥0
c2
k
k! [1 −αk].
Lemma 6 implies that to understand the smoothed population Lλ(w) = (LλL)(w), it suffices to
understand Lλ(αk) for k ≥0. First, we will show that the set of single index models is closed under
smoothing operator Lλ:
Lemma 7. Let g : [−1, 1] →R and let u ∈Sd−1. Then
Lλ(g(w · u)) = gλ(w · u)
where
gλ(α) := Ez∼Unif(Sd−2)
"
g
 
α + λz1
√
1 −α2
√
1 + λ2
!#
and z1 denotes the first coordinate of z.
16

Proof. Expanding the definition of Lλ gives:
Lλ(g(w · u)) = Ez∼µw

g
 w + λz
∥w + λz∥· u

= Ez∼µw

g
w · u + λz · u
√
1 + λ2

.
Now I claim that when z ∼µw, z·u
d= z1
p
1 −(w · u)2 where z Unif(∼Unif(Sd−2)) which would
complete the proof. To see this, note that we can decompose Rd into span{w} ⊕span{w}⊥. Under
this decomposition we have the polyspherical decomposition z
d= (0, z′) where z′ ∼Unif(Sd−2).
Then
z · u = z′ · P ⊥
w u
d= z1∥P ⊥
w u∥= z1
p
1 −(w · u)2.
Of central interest are the quantities Lλ(αk) as these terms show up when smoothing the population
loss (see Lemma 6). We begin by defining the quantity sk(α; λ) which will provide matching upper
and lower bounds on Lλ(αk) when α ≥0:
Definition 12. We define sk(α; λ) by
sk(α; λ) :=
1
(1 + λ2)k/2









αk
α2 ≥λ2
d

λ2
d
 k
2
α2 ≤λ2
d and k is even
α

λ2
d
 k−1
2
α2 ≤λ2
d and k is odd
.
Lemma 8. For all k ≥0 and α ≥0, there exist constants c(k), C(k) such that
c(k)sk(α; λ) ≤Lλ(αk) ≤C(k)sk(α; λ).
Proof. Using Lemma 7 we have that
Lλ(αk) = Ez∼Unif(Sd−2)


 
α + λz1
√
1 −α2
√
1 + λ2
!k

= (1 + λ2)−k/2
k
X
j=0
k
j

αk−jλj(1 −α2)j/2 Ez∼Unif(Sd−2)[zj
1].
Now note that when j is odd, Ez∼Unif(Sd−2)[zj
1] = 0 so we can re-index this sum to get
Lλ(αk) = (1 + λ2)−k/2
⌊k
2 ⌋
X
j=0
 k
2j

αk−2jλ2j(1 −α2)j Ez∼Unif(Sd−2)[z2j
1 ]
= (1 + λ2)−k/2
⌊k
2 ⌋
X
j=0
 k
2j

αk−2jλ2j(1 −α2)jν(d−1)
j
.
Note that every term in this sum is non-negative. Now we can ignore constants depending on k and
use that ν(d−1)
j
≍d−j to get
Lλ(αk) ≍

α
√
1 + λ2
k ⌊k
2 ⌋
X
j=0
λ2(1 −α2)
α2d
j
.
Now when α2 ≥λ2
d , this is a decreasing geometric series which is dominated by the first term so
Lλ(αk) ≍
  α
λ
k. Next, when α2 ≤λ2
d we have by Assumption 2 that α ≤1
C so 1 −α2 is bounded
17

away from 0. Therefore the geometric series is dominated by the last term which is
1
(1 + λ2)−k/2






λ2
d
 k
2
k is even
α

λ2
d
 k−1
2
k is odd
which completes the proof.
Next, in order to understand the population gradient, we need to understand how the smoothing
operator Lλ commutes with differentiation. We note that these do not directly commute because
the smoothing distribution µw depends on w so this term must be differentiated as well. However,
smoothing and differentiation almost commute, which is described in the following lemma:
Lemma 9. Define the dimension-dependent univariate smoothing operator by:
L(d)
λ g(α) := Ez∼Unif(Sd−2)
"
g
 
α + λz1
√
1 −α2
√
1 + λ2
!#
.
Then,
d
dαL(d)
λ (g(α)) = L(d)
λ (g′(α))
√
1 + λ2
−
λ2α
(1 + λ2)(d −1)L(d+2)
λ
(g′′(α)).
Proof. Directly differentiating the definition for L(d)
λ
gives
d
dαL(d)
λ
= L(d)
λ (g′(α))
√
1 + λ2
−Ez∼Unif(Sd−2)
"
αλz1
p
(1 + λ2)(1 −α2)
g′
 
α + λz1
√
1 −α2
√
1 + λ2
!#
.
By Lemma 25, this is equal to
d
dαL(d)
λ
= L(d)
λ (g′(α))
√
1 + λ2
−
λ2α
(1 + λ2)(d −1) Ez∼Unif(Sd)
"
g′′
 
α + λz1
√
1 −α2
√
1 + λ2
!#
= L(d)
λ (g′(α))
√
1 + λ2
−
λ2α
(1 + λ2)(d −1)L(d+2)
λ
(g′′(α)).
Now we are ready to analyze the population gradient:
Lemma 10.
∇wLλ(w) = −(w⋆−αw)cλ(α)
where for α ≥C−1/4d−1/2,
cλ(α) ≍sk⋆−1(α; λ)
√
1 + λ2
.
Proof. Recall that
L(w) = 1 −
X
k≥0
c2
k
k! αk.
Because k⋆is the index of the first nonzero Hermite coefficient, we can start this sum at k = k⋆.
Smoothing and differentiating gives:
∇wLλ(w) = −(w⋆−αw)cλ(α)
where
cλ(α) :=
X
k≥k⋆
c2
k
k!
d
dαLλ(αk).
18

We will break this into the k = k⋆term and the k > k⋆tail. First when k = k⋆we can use Lemma 9
and Lemma 8 to get:
c2
k⋆
(k⋆)!
d
dαLλ(αk⋆) = c2
k⋆
(k⋆)!
"
k⋆Lλ(αk⋆−1)
√
1 + λ2
−k⋆(k⋆−1)λ2αL(d+2)
λ
(αk⋆−2)
(1 + λ2)(d −1)
#
.
The first term is equal up to constants to sk⋆−1(α;λ)
√
1+λ2
while the second term is equal up to constants to
λ2α
(1+λ2)dsk⋆−2(α; λ). However, we have that
λ2α
(1+λ2)dsk⋆−2(α; λ)
sk⋆−1(α;λ)
√
1+λ2
=





λ2
d
α2 ≥λ2
d
λ2
d
α2 ≤λ2
d and k⋆is even
α2
α2 ≤λ2
d and k⋆is odd
≤λ2
d ≤1
C .
Therefore the k = k⋆term in cλ(α) is equal up to constants to sk⋆−1(α;λ)
√
1+λ2
.
Next, we handle the k > k⋆tail. By Lemma 9 this is equal to
X
k>k⋆
c2
k
k!
"
kLλ(αk−1)
√
1 + λ2
−k(k −1)λ2αL(d+2)
λ
(αk−2)
(1 + λ2)(d −1)
#
.
Now recall that from Lemma 8, Lλ(αk) is always non-negative so we can use c2
k ≤k! to bound this
tail in absolute value by
X
k>k⋆
kLλ(αk−1)
√
1 + λ2
+ k(k −1)λ2αL(d+2)
λ
(αk−2)
(1 + λ2)(d −1)
≲
1
√
1 + λ2 Lλ
 X
k>k⋆
kαk−1
!
+
λ2α
(1 + λ2)dL(d+2)
λ
 X
k>k⋆
k(k −1)αk−2
!
≲
1
√
1 + λ2 Lλ

αk⋆
(1 −α)2

+
λ2α
(1 + λ2)dL(d+2)
λ
 αk⋆−1
(1 −α)3

.
Now by Corollary 3, this is bounded for d ≥5 by
sk⋆(α; λ)
√
1 + λ2 +
λ2α
(1 + λ2)dsk⋆−1(α; λ).
For the first term, we have
sk⋆(α; λ)
sk⋆−1(α; λ) =





α
λ
α2 ≥λ2
d
λ
dα
α2 ≤λ2
d and k⋆is even
α
λ
α2 ≤λ2
d and k⋆is odd
≤C−1/4.
The second term is trivially bounded by
λ2α
(1 + λ2)d ≤
λ2
(1 + λ2)d ≤
1
C(1 + λ2) ≤
1
C
√
1 + λ2
which completes the proof.
B.3
Concentrating the Empirical Gradient
We cannot directly apply Lemma 7 to σ(w · x) as ∥x∦= 1. Instead, we will use the properties of the
Hermite tensors to directly smooth σ(w · x).
Lemma 11.
Lλ(Hek(w · x)) = ⟨Hek(x), Tk(w)⟩
where
Tk(w) = (1 + λ2)−k
2
⌊k
2 ⌋
X
j=0
 k
2j

w⊗(k−2j) e⊗(P ⊥
w )e⊗jλ2jν(d−1)
j
.
19

Proof. Using Lemma 5, we can write
Lλ(Hek(w · x)) =

Hek(x), Lλ
 w⊗k
.
Now
Tk(w) = Lλ(w⊗k)
= Ez∼µw
" w + λz
√
1 + λ2
⊗k#
= (1 + λ2)−k
2
k
X
j=0
k
j

w⊗(k−j) e⊗Ez∼µw[z⊗j]λj.
Now by Lemma 2, this is equal to
Tk(w) = (1 + λ2)−k
2
⌊k
2 ⌋
X
j=0
 k
2j

w⊗(k−2j) e⊗(P ⊥
w )e⊗jλ2jν(d−1)
j
which completes the proof.
Lemma 12. For any u ∈Sd−1 with u ⊥w,
Ex∼N(0,Id)
h
(u · ∇wLλ(Hek(w · x)))2i
≲k!

k2
1 + λ2 Lλ
 αk−1
+
λ4k4
(1 + λ2)2d2 L(d+2)
λ
 αk−2
α=
1
√
1+λ2
.
Proof. Recall that by Lemma 11 we have
Lλ(Hek(w · x)) = ⟨Hek(x), Tk(w)⟩
where
Tk(w) := (1 + λ2)−k
2
⌊k
2 ⌋
X
j=0
 k
2j

w⊗(k−2j) e⊗(P ⊥
w )e⊗jλ2jν(d−1)
j
.
Differentiating this with respect to w gives
u · ∇wLλ(Hek(w · x)) = ⟨Hek(x), ∇wTk(w)[u]⟩.
Now note that by Lemma 5:
Ex∼N(0,Id)
h
(u · ∇wLλ(Hek(w · x)))2i
= Ex∼N(0,Id)
h
⟨Hek(x), ∇wTk(w)[u]⟩2i
= k!∥∇wTk(w)[u]∥2
F .
Therefore it suffices to compute the Frobenius norm of ∇wTk(w)[u]. We first explicitly differentiate
Tk(w):
∇wTk(w)[u] = (1 + λ2)−k
2
⌊k
2 ⌋
X
j=0
 k
2j

(k −2j)u e⊗w⊗k−2j−1 e⊗(P ⊥
w )e⊗jλ2jν(d−1)
j
−(1 + λ2)−k
2
⌊k
2 ⌋
X
j=0
 k
2j

(2j)u e⊗w⊗k−2j+1 e⊗(P ⊥
w )e⊗(j−1)λ2jν(d−1)
j
=
k
(1 + λ2)
k
2
⌊k−1
2
⌋
X
j=0
k −1
2j

u e⊗w⊗k−1−2j e⊗(P ⊥
w )e⊗jλ2jν(d−1)
j
−
λ2k(k −1)
(d −1)(1 + λ2)
k
2
⌊k−2
2
⌋
X
j=0
k −2
2j

u e⊗w⊗k−1−2j e⊗(P ⊥
w )e⊗jλ2jν(d+1)
j
.
20

Taking Frobenius norms gives
∥∇wTk(w)[u]∥2
F
≲
k2
(1 + λ2)k

⌊k−1
2
⌋
X
j=0
k −1
2j

u e⊗w⊗k−1−2j e⊗(P ⊥
w )e⊗jλ2jν(d−1)
j

2
F
+
λ4k4
(d −1)2(1 + λ2)k

⌊k−2
2
⌋
X
j=0
k −2
2j

u e⊗w⊗k−1−2j e⊗(P ⊥
w )e⊗jλ2jν(d+1)
j

2
F
.
Now we can use Lemma 1 to pull out u and get:
∥∇wTk(w)[u]∥2
F
≲
k2
(1 + λ2)k

⌊k−1
2
⌋
X
j=0
k −1
2j

w⊗k−1−2j e⊗(P ⊥
w )e⊗jλ2jν(d−1)
j

2
F
+
λ4k4
d2(1 + λ2)k

⌊k−2
2
⌋
X
j=0
k −2
2j

w⊗k−1−2j e⊗(P ⊥
w )e⊗jλ2jν(d+1)
j

2
F
.
Now note that the terms in each sum are orthogonal as at least one w will need to be contracted with
a P ⊥
w . Therefore this is equivalent to:
∥∇wTk(w)[u]∥2
F
≲
k2
(1 + λ2)k
⌊k−1
2
⌋
X
j=0
k −1
2j
2
λ4j(ν(d−1)
j
)2w⊗k−1−2j e⊗(P ⊥
w )e⊗j
2
F
+
λ4k4
d2(1 + λ2)k
⌊k−2
2
⌋
X
j=0
k −2
2j
2
λ4j(ν(d+1)
j
)2w⊗k−1−2j e⊗(P ⊥
w )e⊗j
2
F .
Next, note that for any k tensor A, ∥Sym(A)∥2
F
=
1
k!
P
π∈Sk ⟨A, π(A)⟩.
When A
=
w⊗k−2j e⊗(P ⊥
w )e⊗j, the only permutations that don’t give 0 are the ones which pair up all of the ws
of which there are (2j)!(k −2j)!. Therefore, by Lemma 3,
w⊗k−2j e⊗(P ⊥
w )e⊗j
2
F =
1
  k
2j

(P ⊥
w )e⊗j
2
F =
1
ν(d−1)
j
  k
2j
.
Plugging this in gives:
∥∇wTk(w)[u]∥2
F
≲
k2
(1 + λ2)k
⌊k−1
2
⌋
X
j=0
k −1
2j

λ4jν(d−1)
j
+
λ4k4
d2(1 + λ2)k
⌊k−2
2
⌋
X
j=0
k −2
2j

λ4jν(d+1)
j
.
Now note that
Lλ(αk)

α=
1
√
1+λ2
=
1
(1 + λ2)k
⌊k
2 ⌋
X
k=0
 k
2j

λ4jν(d−1)
j
which completes the proof.
21

Corollary 1. For any u ∈Sd−1 with u ⊥w,
Ex∼N(0,Id)
h
(u · ∇wLλ(σ(w · x)))2i
≲
min

1 + λ2,
√
d
−(k⋆−1)
1 + λ2
.
Proof. Note that
Lλ(σ(w · x)) =
X
k
ck
k! ⟨Hek(x), Tk(w)⟩
so
u · ∇wLλ(σ(w · x)) =
X
k
ck
k! ⟨Hek(x), ∇wTk(w)[u]⟩.
By Lemma 4, these terms are orthogonal so by Lemma 12,
Ex∼N(0,Id)
h
(u · ∇wLλ(σ(w · x)))2i
≲
X
k
c2
k
k!

k2
1 + λ2 Lλ
 αk−1
+
λ4k4
(1 + λ2)2d2 L(d+2)
λ
 αk−2
α=
1
√
1+λ2
≲
1
1 + λ2 Lλ
 αk⋆−1
(1 −α)3

+
λ4
(1 + λ2)2d2 L(d+2)
λ
 αk⋆−2
(1 −α)5

≲
1
1 + λ2 sk⋆−1

1
√
1 + λ2 ; λ

+
λ4
(1 + λ2)2dsk⋆−2

1
√
1 + λ2 ; λ

≲
1
1 + λ2 sk⋆−1
 λ−1; λ

+
λ4
(1 + λ2)2dsk⋆−2
 λ−1; λ

.
Now plugging in the formula for sk(α; λ) gives:
Ex∼N(0,Id)
h
(u · ∇wLλ(σ(w · x)))2i
≲(1 + λ2)−k⋆+1
2



(1 + λ2)−k⋆−1
2
1 + λ2 ≤
√
d

1+λ2
d
 k⋆−1
2
1 + λ2 ≥
√
d
≲
min

1 + λ2,
√
d
−(k⋆−1)
1 + λ2
.
The following lemma shows that ∇wLλ(σ(w · x)) inherits polynomial tails from σ′:
Lemma 13. There exists an absolute constant C such that for any u ∈Sd−1 with u ⊥w and any
p ∈[0, d/C],
Ex∼N(0,Id) [(u · ∇wLλ(σ(w · x)))p]1/p ≲
pC
√
1 + λ2 .
Proof. Following the proof of Lemma 9 we have
u · ∇wLλ(σ(w · x))
= (u · x) Ez1∼Unif(Sd−2)
"
σ′
 
w · x + λz1
P ⊥
w x

√
1 + λ2
!
1
√
1 + λ2 −
λz1(w · x)
∥P ⊥
w x∥
√
1 + λ2
#
.
First, we consider the first term. Its p norm is bounded by
1
√
1 + λ2 Ex

(u · x)2p
Ex

Ez1∼Unif(Sd−2)
"
σ′
 
w · x + λz1
P ⊥
w x

√
1 + λ2
!#2p
.
22

By Jensen we can pull out the expectation over z1 and use Assumption 1 to get
1
√
1 + λ2 Ex[(u · x)2p] Ex∼N(0,Id),z1∼Unif(Sd−2)

σ′
 
w · x + λz1
P ⊥
w x

√
1 + λ2
!2p

=
1
√
1 + λ2 Ex∼N(0,1)[x2p] Ex∼N(0,1) [σ′(x)p]
≲poly(p)
√
1 + λ2 .
Similarly, the p norm of the second term is bounded by
λ
√
1 + λ2 · poly(p) · Ex,z1
"z1(x · w)
∥P ⊥
w ∥
2p# 1
2p
≲
λ
d
√
1 + λ2 poly(p) ≪poly(p)
√
1 + λ2 .
Finally, we can use Corollary 1 and Lemma 13 to bound the p norms of the gradient:
Lemma 14. Let (x, y) be a fresh sample and let v = −∇Lλ(w; x; y). Then there exists a constant
C such that for any u ∈Sd−1 with u ⊥w, any λ ≤d1/4 and all 2 ≤p ≤d/C,
Ex,y [(u · v)p]1/p ≲poly(p) · ˜O

(1 + λ2)−1
2 −k⋆−1
p

.
Proof. First,
Ex,y[(u · v)p]1/p = Ex,y[(u · ∇Lλ(w; B))p]1/p
= Ex,y[yp(u · ∇wLλ(σ(w · x))p]1/p.
Applying Lemma 23 with X = (u · ∇wLλ(σ(w · x)))2 and Y = yp(u · ∇wLλ(σ(w · x)))p−2 gives:
Ex,y[(u · v)p]1/p ≲poly(p) ˜O




min

1 + λ2,
√
d
−k⋆−1
p
√
1 + λ2




≲poly(p) · ˜O

(1 + λ2)−1
2 −k⋆−1
p

which completes the proof.
Corollary 2. Let v, ϵ be as in Lemma 14. Then for all 2 ≤p ≤d/C,
Ex,y[∥v∥2p]1/p ≲poly(p) · d · ˜O

(1 + λ2)−1−k⋆−1
p

.
Proof. By Jensen’s inequality,
∥v∥2p = E
" d
X
i=1
(v · ei)2
!p#
≲dp−1 E
" d
X
i=1
(v · ei)2p
#
≲dp max
i
E[(z · ei)2p].
Taking pth roots and using Lemma 14 finishes the proof.
B.4
Analyzing the Dynamics
Throughout this section we will assume 1 ≤λ ≤d1/4. The proof of the dynamics is split into three
stages.
In the first stage, we analyze the regime α ∈[α0, λd−1/2]. In this regime, the signal is dominated by
the smoothing.
23

In the second stage, we analyze the regime α ∈[λd−1/2, 1 −od(1)]. This analysis is similar to the
analysis in Ben Arous et al. [1] and could be equivalently carried out with λ = 0.
Finally in the third stage, we decay the learning rate linearly to achieve the optimal rate
n ≳d
k⋆
2 + d
ϵ .
All three stages will use the following progress lemma:
Lemma 15. Let w ∈Sd−1 and let α := w · w⋆. Let (x, y) be a fresh batch and define
v := −∇wLλ(w; x; y),
z := v −Ex,y[v],
w′ =
w + λv
∥w + λv∥
and
α′ := w′ · w⋆.
Then if η ≲α
√
1 + λ2,
α′ = α + η(1 −α2)cλ(α) + Z + ˜O

η2dα
(1 + λ2)k⋆

.
where Ex,y[Z] = 0 and for all 2 ≤p ≤d/C,
Ex,y[Zp]1/p ≤˜O(poly(p))
h
η(1 + λ2)−1
2 −(k⋆−1)
p
ip
1 −α2 +
ηdα
√
1 + λ2

.
Furthermore, if λ = O(1) the ˜O(·) can be replaced with O(·).
Proof. Because v ⊥w and 1 ≥
1
√
1+x2 ≥1 −x2
2 ,
α′ = α + η(v · w⋆)
q
1 + η2∥v∥2 = α + η(v · w⋆) + r
where |r| ≤η2
2 ∥v∥2[α + η|v · w⋆|]. Note that by Lemma 14, η(v · w⋆) has moments bounded by
η
λ poly(p) ≲α poly(p). Therefore by Lemma 23 with X = ∥v∥2 and Y = α + η|v · w⋆|,
Ex,y[r] ≤˜O

η2 E[∥v∥2]α

.
Plugging in the bound on E[∥v∥2] from Corollary 2 gives
Ex,y[α′] = α + η(1 −α2)cλ(α) + ˜O

η2dα(1 + λ2)−k⋆
.
In addition, by Lemma 14,
Ex,y [|η(v · w⋆) −Ex,y[η(v · w⋆)]|p]1/p ≲poly(p) · η ·
P ⊥
w w⋆ · ˜O

(1 + λ2)−1
2 −k⋆−1
p

= poly(p) · η ·
p
1 −α2 · ˜O

(1 + λ2)−1
2 −k⋆−1
p

.
Similarly, by Lemma 23 with X = ∥v∥2 and Y = ∥v∥2(p−1)[α + η|v · w|]p, Lemma 14, and
Corollary 2,
Ex,y [|rt −Ex,y[rt]|p]1/p ≲Ex,y [|rt|p]1/p
≲η2α poly(p) ˜O
 
d
(1 + λ2)k⋆
1/p
d
1 + λ2
 p−1
p !
= poly(p) · η2dα · ˜O

(1 + λ2)−1−k⋆−1
p

.
We can now analyze the first stage in which α ∈[d−1/2, λ · d−1/2]. This stage is dominated by the
signal from the smoothing.
24

Lemma 16 (Stage 1). Assume that λ ≥1 and α0 ≥1
C d−1/2. Set
η = d−k⋆
2 (1 + λ2)k⋆−1
log(d)C
and
T1 = C(1 + λ2)d
k⋆−2
2
log(d)
η
= ˜O

dk⋆−1λ−2k⋆+4
for a sufficiently large constant C. Then with high probability, there exists t ≤T1 such that
αt ≥λd−1/2.
Proof. Let τ be the hitting time for ατ ≥λd−1/2. For t ≤T1, let Et be the event that
αt ≥1
2

α0 + η
t−1
X
j=0
cλ(αj)

.
We will prove by induction that for any t ≤T1, the event: {Et or t ≥τ} happens with high
probability. The base case of t = 0 is trivial so let t ≥0 and assume the result for all s < t. Note that
η/λ ≪d−1/2
C
≤αj so by Lemma 15 and the fact that λ ≥1,
αt = α0 +
t−1
X
j=0
h
η(1 −α2
j)cλ(αj) + Zj + ˜O

η2dαjλ−2k⋆i
.
Now note that P[Et or t ≥τ] = 1 −P [!Et and t < τ] so let us condition on the event t < τ. Then
by the induction hypothesis, with high probability we have αs ∈[ α0
2 , λd−1/2] for all s < t. Plugging
in the value of η gives:
η(1 −α2
j)cλ(αj) + ˜O

η2dαjλ−2k⋆
≥η(1 −α2
j)cλ(αj) −ηd−k⋆−2
2
λ−2αj
C
≥ηcλ(αj)
2
.
Similarly, because Pt−1
j=0 Zj is a martingale we have by Lemma 22 and Lemma 24 that with high
probability,
t−1
X
j=0
Zj ≲˜O
hp
T1 · ηλ−k⋆+ ηλ−1i
1 + max
j<t
ηdαj
λ

≲˜O
p
T1 · ηλ−k⋆+ ηλ−1
≤d−1/2
C
.
where we used that ηdαj/λ ≤η
√
d ≪1. Therefore conditioned on t ≤τ we have with high
probability that for all s ≤t:
αt ≥1
2

α0 + η
t−1
X
j=0
cλ(αj)

.
Now we split into two cases depending on the parity of k⋆. First, if k⋆is odd we have that with high
probability, for all t ≤T1:
αt ≳α0 + ηtλ−1d−k⋆−1
2
or
t ≥τ.
Now let t = T1. Then we have that with high probability,
αt ≥λd−1/2
or
τ ≤T1
which implies that τ ≤T1 with high probability. Next, if k⋆is even we have that with high probability
αt ≳α0 + η · d−k⋆−2
2
λ2
t−1
X
s=0
αs
or
t ≥τ.
As above, by Lemma 27 the first event implies that αT1 ≥λd−1/2 so we must have τ ≤T1 with high
probability.
25

Next, we consider what happens when α ≥λd−1/2. The analysis in this stage is similar to the online
SGD analysis in [1].
Lemma 17 (Stage 2). Assume that α0 ≥λd−1/2. Set η, T1 as in Lemma 16. Then with high
probability, αT1 ≥1 −d−1/4.
Proof. The proof is almost identical to Lemma 16. We again have from Lemma 15
αt ≥α0 +
t−1
X
j=0
h
η(1 −α2
j)cλ(αj) + Zj −˜O

η2dαjλ−2k⋆i
.
First, from martingale concentration we have that
t−1
X
j=0
Zj ≲˜O
hp
T1 · ηλ−k⋆+ ηλ−1i
1 + ηd
λ

≲˜O
hp
T1 · ηλ−k⋆+ ηλ−1i
· λ

≲λd−1/2
C
where we used that η ≪λ2
d . Therefore with high probability,
αt ≥α0
2 +
t−1
X
j=0
h
η(1 −α2
j)cλ(αj) −˜O

η2dαjλ−2k⋆i
≥α0
2 + η
t−1
X
j=0
"
(1 −α2
j)cλ(αj) −αjd−k⋆−2
2
Cλ2
#
.
Therefore while αt ≤1 −
1
k⋆, for sufficiently large C we have
αt ≥α0
2 +
η
C1/2λk⋆
t−1
X
j=0
αk⋆−1
j
.
Therefore by Lemma 27, we have that there exists t ≤T1/2 such that αt ≥1 −
1
k⋆. Next, let
pt = 1 −αt. Then applying Lemma 15 to pt and using (1 −
1
k⋆)k⋆≳1/e gives that if
r := d−k⋆−2
2
Cλ2
and
c :=
1
C1/2λk⋆
then
pt+1 ≤pt −ηcpt + ηr + Zt
= (1 −ηc)pt + ηr + Zt.
Therefore,
pt+s ≤(1 −ηc)spt + r/c +
s−1
X
i=0
(1 −ηc)iZt+s−1−i.
With high probability, the martingale term is bounded by λd−1/2/C as before as long as s ≤T1, so
for s ∈[ C log(d)
ηc
, T1] we have that pt+s ≲C−1/2
 
λ2
d
 k⋆−2
2
+ λd−1/2
!
≲C−1/2d−1/4. Setting
s = T1 −t and choosing C appropriately yields pT1 ≤d−1/4, which completes the proof.
Finally, the third stage guarantees not only a hitting time but a last iterate guarantee. It also achieves
the optimal sample complexity in terms of the target accuracy ϵ:
26

Lemma 18 (Stage 3). Assume that α0 ≥1 −d−1/4. Set λ = 0 and
ηt =
C
C4d + t.
for a sufficiently large constant C. Then for any t ≤exp
 d1/C
, we have that with high probability,
αt ≥1 −O

d
d + t

.
Proof. Let pt = 1 −αt. By Lemma 15, while pt ≤1/k⋆:
pt+1 ≤pt −ηtpt
2C + Cη2
t d + ηt
√pt · Wt + η2
t d · Zt
=
C4d + t −2
C4d + t

pt + Cη2
t d + ηt
√pt · Wt + η2
t d · Zt.
where the moments of Wt, Zt are each bounded by poly(p). We will prove by induction that with
probability at least 1 −t exp
 −Cd1/C/e

, we have for all s ≤t:
ps ≤
2C3d
C4d + s ≤2
C ≤1
k⋆.
The base case is clear so assume the result for all s ≤t. Then from the recurrence above,
pt+1 ≤p0
C8d2
(C4d + t)2 +
1
(C4d + t)2
t
X
j=0
(C4d + j)2
Cη2
j d + ηt
√pt · Wt + η2
t d · Zt

.
First, because p0 ≤d−1/4,
C8p0d2
(C4d + t)2 ≤C4p0d
C4d + t ≪
d
C4d + t.
Next,
1
(C4d + t)2
t
X
j=0
(C4d + j)2Cη2
j d =
1
(C4d + t)2
t
X
j=0
C3d
=
C3dt
(C4d + t)2
≤
C3d
C4d + t.
The next error term is:
1
(C4d + t)2
t
X
j=0
(C4d + j)2ηt
√pt · Wt.
Fix p = d1/C
e . Then we will bound the pth moment of pt:
E[pp
t ] ≤
2C3d
C4d + t + E

pp
t 1pt≥2C3d
C4d+s

≤
 2C3d
C4d + t
p
+ 2p P

pt ≥
2C3d
C4d + t

≤
 2C3d
C4d + t
p
+ 2pt exp

−Cd1/C
.
Now note that because t ≤exp
 d1/C
,
log

t exp

−Cd1/C
= log(t) −Cd1/C ≤−log(t)(C −1)d1/C ≤−p log(t).
27

Therefore E[pp
t ]1/p ≤
4C3d
C4d+t. Therefore the p norm of the predictable quadratic variation of the next
error term is bounded by:
poly(p)
t
X
j=0
(C4d + j)4η2
t E[pp
t ]1/p ≤poly(p)
t
X
j=0
C5d(C4d + j)
≲poly(p)C5dt(C4d + t).
In addition, the p norm of the largest term in this sum is bounded by
poly(p)
p
C5d(C4d + t).
Therefore by Lemma 22 and Lemma 24, we have with probability at least 1 −exp
 Cd−1/C/e

, this
term is bounded by
√
C5dt
(C4d + t)3/2 · d1/2 ≤
C3d
C4d + t.
Finally, the last term is similarly bounded with probability at least 1 −exp
 −Cd−1/C/e

by
C2d
√
t
(C4d + t)2 · d1/2 ≪
C3d
C4d + t
which completes the induction.
We can now combine the above lemmas to prove Theorem 1:
Proof of Theorem 1. By Lemmas 16 to 18, if T = T1 + T2 we have with high probability for all
T2 ≤exp
 d1/C
:
αT ≥1 −O

d
d + T2

.
Next, note that by Bernoulli’s inequality ((1 + x)n ≥1 + nx), we have that 1 −αk ≤k(1 −α).
Therefore,
L(wT ) =
X
k≥0
c2
k
k! [1 −αk
T ]
≤(1 −αT )
X
k≥0
c2
k
(k −1)!
= (1 −αT ) Ex∼N(0,1)[σ′(x)2]
≲
d
d + T2
which completes the proof of Theorem 1.
B.5
Proof of Theorem 2
We directly follow the proof of Theorem 2 in Damian et al. [6] which is reproduced here for
completeness. We begin with the following general CSQ lemma which can be found in Szörényi
[43], Damian et al. [6]:
Lemma 19. Let F be a class of functions and D be a data distribution such that
Ex∼D[f(x)2] = 1
and
|Ex∼D[f(x)g(x)]| ≤ϵ
∀f ̸= g ∈F.
Then any correlational statistical query learner requires at least |F|(τ 2−ϵ)
2
queries of tolerance τ to
output a function in F with L2(D) loss at most 2 −2ϵ.
28

First, we will construct a function class from a subset of F :=

σ(w · x) : w ∈Sd−1	
. By [6,
Lemma 3], for any ϵ there exist 1
2ecϵ2d unit vectors w1, . . . , ws such that their pairwise inner products
are all bounded by ϵ. Let bF := {σ(wi · x) : i ∈[s]}. Then for i ̸= j,
Ex∼N(0,Id)[σ(wi · x)σ(wj · x)]
 =

X
k≥0
c2
k
k! (wi · wj)k

≤|wi · wj|k⋆
≤ϵk⋆.
Therefore by Lemma 19,
4q ≥ecϵ2d(τ 2 −ϵk⋆).
Now set
ϵ =
s
log
 4q(cd)k⋆/2
cd
which gives
τ 2 ≤1 + logk/2(4q(cd)k⋆/2)
(cd)k⋆/2
≲logk⋆/2(qd)
dk⋆/2
.
C
Concentration Inequalities
Lemma 20 (Rosenthal-Burkholder-Pinelis Inequality [44]). Let {Yi}n
i=0 be a martingale with
martingale difference sequence {Xi}n
i=1 where Xi = Yi −Yi−1. Let
⟨Y ⟩=
n
X
i=1
E[∥Xi∥2|Fi−1]
denote the predictable quadratic variation. Then there exists an absolute constant C such that for all
p,
∥Yn∥p ≤C
q
p∥⟨Y ⟩∥p/2 + p
max
i
∥Xi∥

p

.
The above inequality is found in Pinelis [44, Theorem 4.1]. It is often combined with the following
simple lemma:
Lemma 21. For any random variables X1, . . . , Xn,
max
i
∥Xi∥

p ≤
 n
X
i=1
∥Xi∥p
p
!1/p
.
This has the immediate corollary:
Lemma 22. Let {Yi}n
i=0 be a martingale with martingale difference sequence {Xi}n
i=1 where
Xi = Yi −Yi−1. Let ⟨Y ⟩= Pn
i=1 E[∥Xi∥2|Fi−1] denote the predictable quadratic variation. Then
there exists an absolute constant C such that for all p,
∥Yn∥p ≤C
hq
p∥⟨Y ⟩∥p/2 + pn1/p max
i
∥Xi∥p
i
.
We will often use the following corollary of Holder’s inequality to bound the operator norm of a
product of two random variables when one has polynomial tails:
Lemma 23. Let X, Y be random variables with ∥Y ∥p ≤σY pC. Then,
E[XY ] ≤∥X∥1 · σY · (2e)C · max

1, 1
C log
∥X∥2
∥X∥1
C
.
29

Proof. Fix ϵ ∈[0, 1]. Then using Holder’s inequality with 1 = 1 −ϵ + ϵ
2 + ϵ
2 gives:
E[XY ] = E[X1−ϵXϵY ] ≤∥X∥1−ϵ
1
∥X∥ϵ
2∥Y ∥2/ϵ.
Using the fact that X, Y have polynomial tails we can bound this by
E[XY ] = E[X1−ϵXϵY ] ≤∥X∥1−ϵ
1
∥X∥ϵ
2σY (2/ϵ)C.
First, if ∥X∥2 ≥eC∥X∥1, we can set ϵ =
C
log
 ∥X∥2
∥X∥1
 which gives
E[XY ] ≤∥X∥1 · σY ·
2e
C log
∥X∥2
∥X∥1
C
.
Next, if ∥X∥2 ≤eC∥X∥1 we can set ϵ = 1 which gives
E[XY ] ≤∥X∥2∥Y ∥2 ≤∥X∥1σY (2e)C
which completes the proof.
Finally, the following basic lemma will allow is to easily convert between p-norm bounds and
concentration inequalities:
Lemma 24. Let δ ≥0 and let X be a mean zero random variable satisfying
E[|X|p]1/p ≤σXpC
for
p = log(1/δ)
C
for some C. Then with probability at least 1 −δ, |X| ≤σX(ep)C.
Proof. Let ϵ = σX(ep)C. Then,
P[|X| ≥ϵ] = P[|X|p ≥ϵp]
≤E[|X|p]
ϵp
≤(σX)pppC
ϵp
= e−Cp
= δ.
D
Additional Technical Lemmas
The following lemma extends Steins’s lemma (Ex∼N(0,1)[xg(x)] = Ex∼N(0,1)[g′(x)]) to the ultras-
pherical distribution µ(d) where µ(d) is the distribution of z1 when z ∼Unif(Sd−1):
Lemma 25 (Spherical Stein’s Lemma). For any g ∈L2(µ(d)),
Ez∼Unif(Sd−1)[z1g(z1)] = Ez∼Unif(Sd+1)[g′(z1)]
d
where z1 denotes the first coordinate of z.
Proof. Recall that the density of z1 is equal to
(1 −x2)
d−3
2
C(d)
where
C(d) :=
√π · Γ( d−1
2 )
Γ( d
2)
.
Therefore,
Ez∼Unif(Sd−1)[z1g(z1)] =
1
C(d)
Z 1
−1
z1g(z1)(1 −z2
1)
d−3
2 dz1.
30

Now we can integrate by parts to get
Ez∼Unif(Sd−1)[z1g(z1)] =
1
C(d)
Z 1
−1
g′(z1)(1 −z2)
d−1
2
d −1
dz1
=
C(d + 2)
C(d)(d −1) Ez∼Unif(Sd+1)[g′(z1)]
= 1
d Ez∼Unif(Sd+1)[g′(z1)].
Lemma 26. For j ≤d/4,
Ez∼Unif(Sd−1)

zk
1
(1 −z2
1)j

≲Ez∼Unif(Sd−2j−1)
 zk
1

.
Proof. Recall that the PDF of µ(d) is
(1 −x2)
d−3
2
C(d)
where
C(d) :=
√π · Γ( d−1
2 )
Γ( d
2)
.
Using this we have that:
Ez∼Unif(Sd−1)

zk
1
(1 −z2
1)j

=
1
C(d)
Z 1
−1
xk
(1 −x2)j (1 −x2)
d−3
2 dx
=
1
C(d)
Z 1
−1
xk(1 −x2)
d−2j−3
2
dx
= C(d −2j)
C(d)
Ez1∼µ(d−2j)[zk
1]
= Γ( d
2)Γ( d−2j−1
2
)
Γ( d−1
2 )Γ( d−2j
2
)
Ez∼Unif(Sd−2j−1)[zk
1]
≲Ez∼Unif(Sd−2j−1)[zk
1].
We have the following generalization of Lemma 8:
Corollary 3. For any k, j ≥0 with d ≥2j + 1 and α ≥C−1/4d1/2, there exist c(j, k), C(j, k) such
that
Lλ

αk
(1 −α)j

≤C(j, k)sk(α; λ).
Proof. Expanding the definition of Lλ gives:
Lλ

αk
(1 −α)j

= Ez∼Unif(Sd−2)



α+λz1
√
1−α2
√
1+λ2
k

1 −α+λz1
√
1−α2
√
1+λ2
j

.
Now let X = λ
√
1−α2
√
1+λ2 ·

1 −
α
√
1+λ2
−1
and note that by Cauchy-Schwarz, X ≤1. Then,
Lλ

αk
(1 −α)j

=
1

1 −
α
√
1+λ2
j Ez∼Unif(Sd−2)



α+λz
√
1−α2
√
1+λ2
k
(1 −Xz1)j


≍Ez∼Unif(Sd−2)


(1 + Xz1)j
α+λz
√
1−α2
√
1+λ2
k
(1 −X2z2
1)j

.
31

Now we can use the binomial theorem to expand this. Ignoring constants only depending on j, k:
Lλ

αk
(1 −α)j

=
1

1 −
α
√
1+λ2
j Ez∼Unif(Sd−2)



α+λz1
√
1−α2
√
1+λ2
k
(1 −Xz1)j


≍λ−k
k
X
i=0
αk−iλi(1 −α2)i/2 Ez∼Unif(Sd−2)
(1 + Xz1)jzi
1
(1 −X2z2
1)j

≤λ−k
k
X
i=0
αk−iλi(1 −α2)i/2 Ez∼Unif(Sd−2)
(1 + Xz1)jzi
1
(1 −z2
1)j

.
By Lemma 26, the z1 term is bounded by d−i
2 when i is even and Xd−i+1
2
when i is odd. Therefore
this expression is bounded by
α
λ
k ⌊k
2 ⌋
X
i=0
λ2(1 −α2)
α2d
i
+
α
λ
k−1 ⌊k−1
2
⌋
X
i=0
α−2iλ2i(1 −α2)id−(i+1)
≍sk(α; λ) + 1
dsk−1(α; λ).
Now note that
1
dsk−1(α; λ)
sk(α; λ)
=





λ
dα
α2 ≥λ2
d
α
λ
α2 ≤λ2
d and k⋆is even
λ
dα
α2 ≤λ2
d and k⋆is odd
≤C−1/4.
Therefore, sk(α; λ) is the dominant term which completes the proof.
Lemma 27 (Adapted from Abbe et al. [4]). Let η, a0 ≥0 be positive constants, and let ut be a
sequence satisfying
ut ≥a0 + η
t−1
X
s=0
uk
s.
Then, if max0≤s≤t−1 ηuk−1
s
≤log 2
k , we have the lower bound
ut ≥

a−(k−1)
0
−1
2η(k −1)t
−
1
k−1
.
Proof. Consider the auxiliary sequence wt = a0 + η Pt−1
s=0 wk
s. By induction, ut ≥wt. To lower
bound wt, we have that
η = wt −wt−1
wk
t−1
= wt −wt−1
wk
t
· wk
t
wk
t−1
≤
wk
t
wk
t−1
Z wt
wt−1
1
xk dx
=
wk
t
wk
t−1(k −1)

w−(k−1)
t−1
−w−(k−1)
t

≤(1 + ηwk−1
t−1 )k
(k −1)

w−(k−1)
t−1
−w−(k−1)
t

≤(1 + log 2
k )k
(k −1)

w−(k−1)
t−1
−w−(k−1)
t

≤
2
k −1

w−(k−1)
t−1
−w−(k−1)
t

.
32

Therefore
w−(k−1)
t
≤w−(k−1)
t−1
−1
2η(k −1).
Altogether, we get
w−(k−1)
t
≤a−(k−1)
0
−1
2η(k −1)t,
or
ut ≥wt ≥

a−(k−1)
0
−1
2η(k −1)t
−
1
k−1
,
as desired.
E
Additional Experimental Details
To compute the smoothed loss Lλ(w; x; y) we used the closed form for Lλ(Hek(w · x)) (see Ap-
pendix B.3). Experiments were run on 8 NVIDIA A6000 GPUs. Our code is written in JAX [45] and
we used Weights and Biases [46] for experiment tracking.
33

