Published as a conference paper at ICLR 2021
LEARNING INVARIANT REPRESENTATIONS FOR REIN-
FORCEMENT LEARNING WITHOUT RECONSTRUCTION
Amy Zhang∗12
Rowan McAllister∗3
Roberto Calandra2
Yarin Gal4
Sergey Levine3
1McGill University
2Facebook AI Research
3University of California, Berkeley
4OATML group, University of Oxford
ABSTRACT
We study how representation learning can accelerate reinforcement learning from
rich observations, such as images, without relying either on domain knowledge or
pixel-reconstruction. Our goal is to learn representations that provide for effective
downstream control and invariance to task-irrelevant details. Bisimulation metrics
quantify behavioral similarity between states in continuous MDPs, which we pro-
pose using to learn robust latent representations which encode only the task-relevant
information from observations. Our method trains encoders such that distances in
latent space equal bisimulation distances in state space. We demonstrate the effec-
tiveness of our method at disregarding task-irrelevant information using modiﬁed
visual MuJoCo tasks, where the background is replaced with moving distractors
and natural videos, while achieving SOTA performance. We also test a ﬁrst-person
highway driving task where our method learns invariance to clouds, weather, and
time of day. Finally, we provide generalization results drawn from properties of
bisimulation metrics, and links to causal inference.
1
Introduction
Figure 1:
Robust representa-
tions of the visual scene should
be insensitive to irrelevant objects
(e.g., clouds) or details (e.g., car
types), and encode two observa-
tions equivalently if their relevant
details are equal (e.g., road direc-
tion and locations of other cars).
Learning control from images is important for many real world
applications. While deep reinforcement learning (RL) has enjoyed
many successes in simulated tasks, learning control from real vision
is more complex, especially outdoors, where images reveal detailed
scenes of a complex and unstructured world. Furthermore, while
many RL algorithms can eventually learn control from real images
given unlimited data, data-efﬁciency is often a necessity in real trials
which are expensive and constrained to real-time. Prior methods
for data-efﬁcient learning of simulated visual tasks typically use
representation learning. Representation learning summarizes images
by encoding them into smaller vectored representations better suited
for RL. For example, sequential autoencoders aim to learn lossless
representations of streaming observations—sufﬁcient to reconstruct
current observations and predict future observations—from which
various RL algorithms can be trained (Hafner et al., 2018; Lee
et al., 2019; Yarats et al., 2019). However, such methods are task-
agnostic: the models represent all dynamic elements they observe in
the world, whether they are relevant to the task or not. We argue such
representations can easily “distract” RL algorithms with irrelevant
information in the case of real images. The issues of distraction is
less evident in popular simulation MuJoCo and Atari tasks, since any change in observation space is
likely task-relevant, and thus, worth representing. By contrast, visual images that autonomous cars
observe contain predominately task-irrelevant information, like cloud shapes and architectural details,
illustrated in Figure 1.
∗Equal contribution. Corresponding author: amy.x.zhang@mail.mcgill.ca
1

Published as a conference paper at ICLR 2021
Rather than learning control-agnostic representations that focus on accurate reconstruction of clouds
and buildings, we would rather achieve a more compressed representation from a lossy encoder, which
only retains state information relevant to our task. If we would like to learn representations that capture
only task-relevant elements of the state and are invariant to task-irrelevant information, intuitively we
can utilize the reward signal to help determine task-relevance, as shown by Jonschkowski & Brock
(2015). As cumulative rewards are our objective, state elements are relevant not only if they inﬂuence
the current reward, but also if they inﬂuence state elements in the future that in turn inﬂuence future
rewards. This recursive relationship can be distilled into a recursive task-aware notion of state
abstraction: an ideal representation is one that is predictive of reward, and also predictive of itself in
the future.
We propose learning such an invariant representation using the bisimulation metric, where the dis-
tance between two observation encodings correspond to how “behaviourally different” (Ferns &
Precup, 2014) both observations are. Our main contribution is a practical representation learning
method based on the bisimulation metric suitable for downstream control, which we call deep
bisimulation for control (DBC). We additionally provide theoretical analysis that proves value
bounds between the optimal value function of the true MDP and the optimal value function of
the MDP constructed by the learned representation. Empirical evaluations demonstrate our non-
reconstructive approach using bisimulation is substantially more robust to task-irrelevant distractors
when compared to prior approaches that use reconstruction losses or contrastive losses. Our initial
experiments insert natural videos into the background of MoJoCo control task as complex distrac-
tion. Our second setup is a high-ﬁdelity highway driving task using CARLA (Dosovitskiy et al.,
2017), showing that our representations can be trained effectively even on highly realistic images
with many distractions, such as trees, clouds, buildings, and shadows. For example videos see
https://sites.google.com/view/deepbisim4control.
2
Related Work
Our work builds on the extensive prior research on bisimulation in MDP state aggregation.
Reconstruction-based Representations. Early works on deep reinforcement learning from im-
ages (Lange & Riedmiller, 2010; Lange et al., 2012) used a two-step learning process where ﬁrst an
auto-encoder was trained using reconstruction loss to learn a low-dimensional representation, and
subsequently a controller was learned using this representation. This allows effective leveraging of
large, unlabeled datasets for learning representations for control. In practice, there is no guarantee
that the learned representation will capture useful information for the control task, and signiﬁcant
expert knowledge and tricks are often necessary for these approaches to work. In model-based
RL, one solution to this problem has been to jointly train the encoder and the dynamics model
end-to-end (Watter et al., 2015; Wahlström et al., 2015) – this proved effective in learning useful
task-oriented representations. Hafner et al. (2018) and Lee et al. (2019) learn latent state models using
a reconstruction loss, but these approaches suffer from the difﬁculty of learning accurate long-term
predictions and often still require signiﬁcant manual tuning. Gelada et al. (2019) also propose a
latent dynamics model-based method and connect their approach to bisimulation metrics, using a
reconstruction loss in Atari. They show that ℓ2 distance in the DeepMDP representation upper bounds
the bisimulation distance, whereas our objective directly learns a representation where distance in
latent space is the bisimulation metric. Further, their results rely on the assumption that the learned
representation is Lipschitz, whereas we show that, by directly learning a bisimilarity-based represen-
tation, we guarantee a representation that generates a Lipschitz MDP. We show experimentally that
our non-reconstructive DBC method is substantially more robust to complex distractors.
Contrastive-based Representations. Contrastive losses are a self-supervised approach to learn
useful representations by enforcing similarity constraints between data (van den Oord et al., 2018;
Chen et al., 2020). Similarity functions can be provided as domain knowledge in the form of
heuristic data augmentation, where we maximize similarity between augmentations of the same data
point (Laskin et al., 2020) or nearby image patches (Hénaff et al., 2019), and minimize similarity
between different data points. In the absence of this domain knowledge, contrastive representations
can be trained by predicting the future (van den Oord et al., 2018). We compare to such an approach
in our experiments, and show that DBC is substantially more robust. While contrastive losses do
not require reconstruction, they do not inherently have a mechanism to determine downstream task
relevance without manual engineering, and when trained only for prediction, they aim to capture all
2

Published as a conference paper at ICLR 2021
predictable features in the observation, which performs poorly on real images for the same reasons
world models do. A better method would be to incorporate knowledge of the downstream task into
the similarity function in a data-driven way, so that images that are very different pixel-wise (e.g.
lighting or texture changes), can also be grouped as similar w.r.t. downstream objectives.
Bisimulation. Various forms of state abstractions have been deﬁned in Markov decision processes
(MDPs) to group states into clusters whilst preserving some property (e.g. the optimal value, or all
values, or all action values from each state) (Li et al., 2006). The strictest form, which generally
preserves the most properties, is bisimulation (Larsen & Skou, 1989). Bisimulation only groups states
that are indistinguishable w.r.t. reward sequences output given any action sequence tested. A related
concept is bisimulation metrics (Ferns & Precup, 2014), which measure how “behaviorally similar”
states are. Ferns et al. (2011) deﬁnes the bisimulation metric with respect to continuous MDPs,
and propose a Monte Carlo algorithm for learning it using an exact computation of the Wasserstein
distance between empirically measured transition distributions. However, this method does not scale
well to large state spaces. Taylor et al. (2009) relate MDP homomorphisms to lax probabilistic
bisimulation, and deﬁne a lax bisimulation metric. They then compute a value bound based on this
metric for MDP homomorphisms, where approximately equivalent state-action pairs are aggregated.
Most recently, Castro (2020) propose an algorithm for computing on-policy bisimulation metrics,
but does so directly, without learning a representation. They focus on deterministic settings and the
policy evaluation problem. We believe our work is the ﬁrst to propose a gradient-based method for
directly learning a representation space with the properties of bisimulation metrics and show that it
works in the policy optimization setting.
3
Preliminaries
We start by introducing notation and outlining realistic assumptions about underlying structure in the
environment. Then, we review state abstractions and metrics for state similarity.
We assume the underlying environment is a Markov decision process (MDP), described by the tuple
M = (S, A, P, R, γ), where S is the state space, A the action space, P(s′|s, a) the probability of
transitioning from state s ∈S to state s′ ∈S, and γ ∈[0, 1) a discount factor. An “agent” chooses
actions a ∈A according to a policy function a ∼π(s), which updates the system state s′ ∼P(s, a),
yielding a reward r = R(s) ∈R. The agent’s goal is to maximize the expected cumulative discounted
rewards by learning a good policy: maxπ EP[P∞
t=0[γtR(st)]. While our primary concern is learning
from images, we do not address the partial-observability problem explicitly: we instead approximate
stacked pixel observations as the fully-observed system state s (explained further in Appendix B).
Bisimulation is a form of state abstraction that groups states si and sj that are “behaviorally equiv-
alent” (Li et al., 2006). For any action sequence a0:∞, the probabilistic sequence of rewards from
si and sj are identical. A more compact deﬁnition has a recursive form: two states are bisimilar
if they share both the same immediate reward and equivalent distributions over the next bisimilar
states (Larsen & Skou, 1989; Givan et al., 2003).
Deﬁnition 1 (Bisimulation Relations (Givan et al., 2003)). Given an MDP M, an equivalence
relation B between states is a bisimulation relation if, for all states si, sj ∈S that are equivalent
under B (denoted si ≡B sj) the following conditions hold:
R(si, a) = R(sj, a)
∀a ∈A,
(1)
P(G|si, a) = P(G|sj, a)
∀a ∈A,
∀G ∈SB,
(2)
where SB is the partition of S under the relation B (the set of all groups G of equivalent states), and
P(G|s, a) = P
s′∈G P(s′|s, a).
Exact partitioning with bisimulation relations is generally impractical in continuous state spaces, as
the relation is highly sensitive to inﬁnitesimal changes in the reward function or dynamics. For this
reason, Bisimulation Metrics (Ferns et al., 2011; Ferns & Precup, 2014; Castro, 2020) softens the
concept of state partitions, and instead deﬁnes a pseudometric space (S, d), where a distance function
d : S × S 7→R≥0 measures the “behavioral similarity” between two states1.
Deﬁning a distance d between states requires deﬁning both a distance between rewards (to soften
Equation (1)), and distance between state distributions (to soften Equation (2)). Prior works use the
Wasserstein metric for the latter, originally used in the context of bisimulation metrics by van Breugel
1Note that d is a pseudometric, meaning the distance between two different states can be zero, corresponding
to behavioral equivalence.
3

Published as a conference paper at ICLR 2021
& Worrell (2001). The pth Wasserstein metric is deﬁned between two probability distributions Pi
and Pj as Wp(Pi, Pj; d) = (infγ′∈Γ(Pi,Pj)
R
S×S d(si, sj)p dγ′(si, sj))1/p, where Γ(Pi, Pj) is the
set of all couplings of Pi and Pj. This is known as the “earth mover” distance, denoting the cost of
transporting mass from one distribution to another (Villani, 2003). Finally, the bisimulation metric is
the reward difference added to the Wasserstein distance between transition distributions:
Deﬁnition 2 (Bisimulation Metric). From Theorem 2.6 in Ferns et al. (2011) with c ∈[0, 1):
d(si, sj) = max
a∈A (1 −c) · |Ra
si −Ra
sj| + c · W1(Pa
si, Pa
sj; d).
(3)
4
Learning Representations for Control with Bisimulation Metrics
Figure 2: Learning a bisimulation metric represen-
tation: shaded in blue is the main model architecture,
it is reused for both states, like a Siamese network.
The loss is the reward and discounted transition dis-
tribution distances (using Wasserstein metric W).
Algorithm 1 Deep Bisimulation for Control (DBC)
1: for Time t = 0 to ∞do
2:
Encode state zt = φ(st)
3:
Execute action at ∼π(zt)
4:
Record data: D ←D ∪{st, at, st+1, rt+1}
5:
Sample batch Bi ∼D
6:
Permute batch: Bj = permute(Bi)
7:
Train policy: EBi[J(π)]
▷Algorithm 2
8:
Train encoder: EBi,Bj[J(φ)]
▷Equation (4)
9:
Train dynamics: J( ˆP,φ)=( ˆP(φ(st), at)−¯zt+1)2
We propose Deep Bisimulation for Control (DBC), a data-efﬁcient approach to learn control policies
from unstructured, high-dimensional states. In contrast to prior work on bisimulation, which typically
aims to learn a distance function of the form d : S × S 7→R≥0 between states, our aim is instead to
learn representations Z under which ℓ1 distances correspond to bisimulation metrics, and then use
these representations to improve reinforcement learning. Our goal is to learn encoders φ : S 7→Z
that capture representations of states that are suitable to control, while discarding any information
that is irrelevant for control. Any representation that relies on reconstruction of the state cannot do
this, as these irrelevant details are still important for reconstruction. We hypothesize that bisimulation
metrics can acquire this type of representation, without any reconstruction.
Bisimulation metrics are a useful form of state abstraction, but prior methods to train distance
functions either do not scale to pixel observations (Ferns et al., 2011) (due to the max operator
in Equation (3)), or were only designed for the (ﬁxed) policy evaluation setting (Castro, 2020).
By contrast, we learn improved representations for policy inputs, as the policy improves online.
Our π∗-bisimulation metric is learned with gradient decent, and we prove it converges to a ﬁxed
point in Theorem 1 under some assumptions. To train our encoder φ towards our desired relation
d(si, sj) := ||φ(si) −φ(sj)||1, we draw batches of state pairs, and minimise the mean square error
between the on-policy bisimulation metric and ℓ1 distance in the latent space:
J(φ) =

||zi −zj||1 −|ri −rj| −γW2
  ˆP(·|¯zi, ai), ˆP(·|¯zj, aj)
2
,
(4)
where zi = φ(si), zj = φ(sj), r are rewards, and ¯z denotes φ(s) with stop gradients. Equation (4)
also uses a probabilistic dynamics model ˆP which outputs a Gaussian distribution. For this reason,
we use the 2-Wasserstein metric W2 in Equation (4), as opposed to the 1-Wasserstein in Equation (3),
since the W2 metric has a convenient closed form: W2(N(µi, Σi), N(µj, Σj))2 = ||µi −µj||2
2 +
||Σ1/2
i
−Σ1/2
j
||2
F, where || · ||F is the Frobenius norm. For all other distances we continue using the
ℓ1 norm. Our model architecture and training is illustrated by Figure 2 and Algorithm 1.
Algorithm 2 Train Policy (changes to SAC in blue)
1: Get value: V = mini=1,2 ˆQi(ˆφ(s)) −α log π(a|φ(s))
2: Train critics: J(Qi, φ) = (Qi(φ(s)) −r −γV )2
3: Train actor: J(π) = α log p(a|φ(s)) −mini=1,2 Qi(φ(s))
4: Train alpha: J(α) = −α log p(a|φ(s))
5: Update target critics: ˆQi ←τQQi + (1 −τQ) ˆQi
6: Update target encoder: ˆφ ←τφφ + (1 −τφ)ˆφ
Incorporating control. We combine our rep-
resentation learning approach (Algorithm 1)
with the soft actor-critic (SAC) algorithm
(Haarnoja et al., 2018) to devise a practical
reinforcement learning method. We modiﬁed
SAC slightly in Algorithm 2 to allow the value
function to backprop to our encoder, which
can improve performance further (Yarats et al.,
2019; Rakelly et al., 2019). Although, in principle, our method could be combined with any RL
algorithm, including the model-free DQN (Mnih et al., 2015), or model-based PETS (Chua et al.,
4

Published as a conference paper at ICLR 2021
2018). Implementation details and hyperparameter values of DBC are summarized in the appendix,
Table 2. We train DBC by iteratively updating three components in turn: a policy π (in this case SAC),
an encoder φ, and a dynamics model ˆP (lines 7–9, Algorithm 1). We found a single loss function was
less stable to train. The inputs of each loss function J(·) in Algorithm 1 represents which components
are updated. After each training step, the policy π is used to step in the environment, the data is
collected in a replay buffer D, and a batch is randomly selected to repeat training.
5
Generalization Bounds and Links to Causal Inference
While DBC enables representation learning without pixel reconstruction, it leaves open the question
of how good the resulting representations really are. In this section, we present theoretical analysis
that bounds the suboptimality of a value function trained on the representation learned via DBC.
First, we show that our π∗-bisimulation metric converges to a ﬁxed point, starting from the initialized
policy π0 and converging to an optimal policy π∗.
Theorem 1. Let met be the space of bounded pseudometrics on S and π a policy that is continuously
improving. Deﬁne F : met 7→met by
F(d, π)(si, sj) = (1 −c)|rπ
si −rπ
sj| + cW(d)(Pπ
si, Pπ
sj).
(5)
Then F has a least ﬁxed point ˜d which is a π∗-bisimulation metric.
Proof in appendix. As evidenced by Deﬁnition 2, the bisimulation metric has no direct dependence on
the state space. Pixels can change, but bisimilarity will stay the same. Instead, bisimilarity is grounded
in a recursion of future transition probabilities and rewards, which is closely related to the optimal
value function. In fact, the bisimulation metric gives tight bounds on the optimal value function
with discount factor γ. We show this using the property that the optimal value function is Lipschitz
with respect to the bisimulation metric, see Theorem 5 in Appendix (Ferns et al., 2004). This result
also implies that the closer two states are in terms of ˜d, the more likely they are to share the same
optimal actions. This leads us to a generalization bound on the optimal value function of an MDP
constructed from a representation space using bisimulation metrics, ||φ(si) −φ(sj)||1 := ˜d(si, sj).
We can construct a partition of this space for some ϵ > 0, giving us n partitions where 1
n < (1 −c)ϵ.
We denote φ as the encoder that maps from the original state space S to each ϵ-cluster. This ϵ denotes
the amount of approximation allowed, where large ϵ leads to a more compact bisimulation partition
at the expense of a looser bound on the optimal value function.
Theorem 2 (Value bound based on bisimulation metrics). Given an MDP ¯
M constructed by aggre-
gating states in an ϵ-neighborhood, and an encoder φ that maps from states in the original MDP M
to these clusters, the optimal value functions for the two MDPs are bounded as
|V ∗(s) −V ∗(φ(s))| ≤
2ϵ
(1 −γ)(1 −c).
(6)
Proof in appendix. As ϵ →0 the optimal value function of the aggregated MDP converges to the
original. Further, by deﬁning a learning error for φ, L := supsi,sj∈S
||φ(si) −φ(sj)||1 −˜d(si, sj)
,
we can update the bound in Theorem 2 to incorporate L: |V ∗(s) −V ∗(φ(s))| ≤
2ϵ+2L
(1−γ)(1−c).
MDP dynamics have a strong connection to causal inference and causal graphs, which are directed
acyclic graphs (Jonsson & Barto, 2006; Schölkopf, 2019; Zhang et al., 2020). Speciﬁcally, the state
and action at time t causally affect the next state at time t + 1. In this work, we care about the
components of the state space that causally affect current and future reward. Deep bisimulation for
control representations connect to causal feature sets, or the minimal feature set needed to predict a
target variable (Zhang et al., 2020).
Theorem 3 (Connections to causal feature sets (Thm 1 in Zhang et al. (2020))). If we partition
observations using the bisimulation metric, those clusters (a bisimulation partition) correspond to
the causal feature set of the observation space with respect to current and future reward.
This connection tells us that these features are the minimal sufﬁcient statistic of the current and future
reward, and therefore consist of (and only consist of) the causal ancestors of the reward variable r.
Deﬁnition 3 (Causal Ancestors). In a causal graph where nodes correspond to variables and directed
edges between a parent node P and child node C are causal relationships, the causal ancestors
AN(C) of a node are all nodes in the path from C to a root node.
If there are interventions on distractor variables, or variables that control the rendering function q
and therefore the rendered observation but do not affect the reward, the causal feature set will be
5

Published as a conference paper at ICLR 2021
robust to these interventions, and correctly predict current and future reward in the linear function
approximation setting (Zhang et al., 2020). As an example, in autonomous driving, an intervention
can be a change from day to night which affects the observation space but not the dynamics or reward.
Finally, we show that a representation based on the bisimulation metric generalizes to other reward
functions with the same causal ancestors.
Theorem 4 (Task Generalization). Given an encoder φ : S 7→Z that maps observations to a latent
bisimulation metric representation where ||φ(si) −φ(sj)||1 := ˜d(si, sj), Z encodes information
about all the causal ancestors of the reward AN(R).
Proof in appendix. This result shows that the learned representation will generalize to unseen reward
functions, as long as the new reward function has a subset of the same causal ancestors. As an
example, a representation learned for a robot to walk will likely generalize to learning to run, because
the reward function depends on forward velocity and all the factors that contribute to forward velocity.
However, that representation will not generalize to picking up objects, as those objects will be ignored
by the learned representation, since they are not likely to be causal ancestors of a reward function
designed for walking. Theorem 4 shows that the learned representation will be robust to spurious
correlations, or changes in factors that are not in AN(R). This complements Theorem 5, that the
representation is a minimal sufﬁcient statistic of the optimal value function, improving generalization
over non-minimal representations.
Theorem 5 (V ∗is Lipschitz with respect to ˜d). Let V ∗be the optimal value function for a given
discount factor γ. If c ≥γ, then V ∗is Lipschitz continuous with respect to ˜d with Lipschitz constant
1
1−c, where ˜d is a π∗-bisimulation metric.
|V ∗(si) −V ∗(sj)| ≤
1
1 −c
˜d(si, sj).
(7)
See Theorem 5.1 in Ferns et al. (2004) for proof. We show empirical validation of these ﬁndings in
Section 6.2.
6
Experiments
Our central hypothesis is that our non-reconstructive bisimulation based representation learning
approach should be substantially more robust to task-irrelevant distractors. To that end, we evaluate
our method in a clean setting without distractors, as well as a much more difﬁcult setting with
distractors. We compare against several baselines. The ﬁrst is Stochastic Latent Actor-Critic (SLAC,
Lee et al. (2019)), a state-of-the-art method for pixel observations on DeepMind Control that learns a
dynamics model with a reconstruction loss. The second is DeepMDP (Gelada et al., 2019), a recent
method that also learns a latent representation space using a latent dynamics model, reward model, and
distributional Q learning, but for which they needed a reconstruction loss to scale up to Atari. Finally,
we compare against two methods using the same architecture as ours but exchange our bisimulation
loss with (1) a reconstruction loss (“Reconstruction”) and (2) contrastive predictive coding (Oord
et al., 2018) (“Contrastive”) to ground the dynamics model and learn a latent representation.
6.1
Control with Background Distraction
In this section, we benchmark DBC and the previously described baselines on the DeepMind Control
(DMC) suite (Tassa et al., 2018) in two settings and nine environments (Figure 3), finger_spin,
cheetah_run, and walker_walk and additional environments in the appendix.
Default Setting. Here, the pixel observations have simple backgrounds as shown in Figure 3 (top row)
with training curves for our DBC and baselines. We see SLAC, a recent state-of-the-art model-based
representation learning method that uses reconstruction, generally performs best.
Simple Distractors Setting. Next, we include simple background distractors, shown in Figure 3
(middle row), with easy-to-predict motions. We use a ﬁxed number of colored circles that obey the
dynamics of an ideal gas (no attraction or repulsion between objects) with no collisions. Note the
performance of DBC remains consistent, as other methods start decreasing.
Natural Video Setting. Then, we incorporate natural video from the Kinetics dataset (Kay et al.,
2017) as background (Zhang et al., 2018), shown in Figure 3 (bottom row). The results conﬁrm our
hypothesis: although a number of prior methods can learn effectively in the absence of distractors,
when complex distractions are introduced, our non-reconstructive bisimulation based method attains
substantially better results.
6

Published as a conference paper at ICLR 2021
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
200
400
600
800
1000
AverageReturn
finger/spin
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
800
900
AverageReturn
cheetah/run
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
200
400
600
800
AverageReturn
walker/walk
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
200
400
600
800
AverageReturn
finger/spin
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
AverageReturn
cheetah/run
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
800
AverageReturn
walker/walk
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
200
400
600
800
AverageReturn
finger/spin
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
50
100
150
200
250
300
AverageReturn
cheetah/run
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
AverageReturn
walker/walk
Figure 3: Left observations: Pixel observations in DMC in the default setting (top row) of the ﬁnger spin (left
column), cheetah (middle column), and walker (right column), with simple distractors (middle row), and natural
video distractors (bottom row). Right training curves: Results comparing out DBC method to baselines on 10
seeds with 1 standard error shaded in the default setting. The grid-location of each graph corresponds to the
grid-location of each observation.
Figure 4: t-SNE of latent spaces learned with a bisimulation metric (left t-SNE) and VAE (right t-SNE)
after training has completed, color-coded with predicted state values (higher value yellow, lower value purple).
Neighboring points in the embedding space learned with a bisimulation metric have similar states and correspond
to observations with the same task-related information (depicted as pairs of images with their corresponding
embeddings), whereas no such structure is seen in the embedding space learned by VAE, where the same image
pairs are mapped far away from each other.
To visualize the representation learned with our bisimulation metric loss function in Equation (4), we
use a t-SNE plot (Figure 4). We see that even when the background looks drastically different, our en-
coder learns to ignore irrelevant information and maps observations with similar robot conﬁgurations
near each other. See Appendix D for another visualization.
6.2
Generalization Experiments
We test generalization of our learned representation in two ways. First, we show that the learned
representation space can generalize to different types of distractors, by training with simple distractors
and testing on the natural video setting. Second, we show that our learned representation can be
useful reward functions other than those it was trained for.
Generalizing over backgrounds. We ﬁrst train on the simple distractors setting and eval-
uate on natural video. Figure 5 shows an example of the simple distractors setting
and performance during training time of two experiments, blue being the zero-shot transfer to the
natural video setting, and orange the baseline which trains on natural video. This result
empirically validates that the representations learned by DBC are able to effectively learn to ignore
the background, regardless of what the background contains or how dynamic it is.
7

Published as a conference paper at ICLR 2021
Generalizing over reward functions. We evaluate (Figure 5) the generalization capabilities of
the learned representation by training SAC with new reward functions walker_stand and
walker_run using the ﬁxed representation learned from walker_walk. This is empirical
evidence that conﬁrms Theorem 4: if the new reward functions are causally dependent on a subset of
the same factors that determine the original reward function, then our representation is sufﬁcient.
0
200000
400000
600000
800000
1000000
step
0
100
200
300
400
500
600
700
episode_reward
DBC: Transfer ideal gas to kinetics
DBC: Trained on kinetics
DeepMDP: Transfer ideal gas to kinetics
0
200000
400000
600000
800000
1000000
step
100
200
300
400
500
600
700
800
900
1000
episode_reward
SAC trained on observation
SAC trained with frozen DBC encoder
SAC trained with frozen DeepMDP encoder
0
200000
400000
600000
800000
1000000
step
50
100
150
200
250
300
episode_reward
SAC trained on observation
SAC trained with frozen DBC encoder
SAC trained with frozen DeepMDP encoder
Figure 5: Generalization of a model trained on simple distractors environment and evaluated on
kinetics (left). Generalization of an encoder trained on walker_walk environment and evaluated on
walker_stand (center) and walker_run (right), all in the simple distractors setting. 10 seeds, 1
standard error shaded.
6.3
Comparison with other Bisimulation Encoders
Even though the purpose of bisimulation metrics by Castro (2020) is learning distances d, not
representation spaces Z, it nevertheless implements d with function approximation: d(si, sj) =
ψ
 φ(si), φ(sj)

by encoding observations with φ before computing distances with ψ, trained as:
J(φ, ψ) =

ψ
 φ(si), φ(sj)

−|ri −rj| −γ ˆψ

ˆφ
 P(si, π(si))

, ˆφ
 P(sj, π(sj))
2
,
(8)
0
100000
200000
300000
400000
500000
600000
700000
800000
step
0
100
200
300
400
500
600
700
episode_reward
walker_walk with natural video
DBC
Castro
Figure 6: Bisim. results. Blue is DBC
and orange is Castro (2020).
where ˆφ and ˆψ are target networks. A natural question is: how
does the encoder φ above perform in control tasks? We com-
bine φ above with our policy in Algorithm 2 and use the same
network ψ (single hidden layer 729 wide). Figure 6 shows rep-
resentations from Castro (2020) can learn control (surprisingly
well given it was not designed to), but our method learns faster.
Further, our method is simpler: by comparing Equation (8)
to Equation (4), our method uses the ℓ1 distance between the
encoding instead of introducing an addition network ψ.
6.4
Autonomous Driving with Visual Redundancy
Figure 7: The driving task is to drive the red ego car
(left) safely in trafﬁc (middle) along a highway (right).
Real-world control systems such as robotics
and autonomous vehicles must contend with
a huge variety of task-irrelevant information,
such as irrelevant objects (e.g. clouds) and ir-
relevant details (e.g. obstacle color). To eval-
uate DBC on tasks with more realistic obser-
vations, we construct a highway driving sce-
nario with photo-realistic visual observations using the CARLA simulator (Dosovitskiy et al.,
2017) shown in Figure 7.
The agent’s goal is to drive as far as possible along CARLA’s
Town04’s ﬁgure-8 the highway in 1000 time-steps without colliding into the 20 other moving
vehicles or barriers. Our objective function rewards highway progression and penalises collisions:
rt = v⊤
egoˆuhighway · ∆t −λi · impulse −λs · |steer|, where vego is the velocity vector of the ego vehi-
cle, projected onto the highway’s unit vector ˆuhighway, and multiplied by time discretization ∆t = 0.05
to measure highway progression in meters. Collisions result in impulses ∈R+, measured in Newton-
seconds. We found a steering penalty steer ∈[−1, 1] helped, and used weights λi = 10−4 and
λs = 1. While more specialized objectives exist like lane-keeping, this experiment’s purpose is only
to compare representations with observations more characteristic of real robotic tasks. We use ﬁve
cameras on the vehicle’s roof, each with 60 degree views. By concatenating the images together, our
vehicle has a 300 degree view, observed as 84 × 420 pixels. Code and install instructions in appendix.
Results in Figure 9 compare the same baselines as before, except for SLAC which is easily distracted
(Figure 3). Instead we used SAC, which does not explicitly learn a representation, but performs
surprisingly well from raw images. DeepMDP performs well too, perhaps given its similarly to
bisimulation. But, Reconstruction and Contrastive methods again perform poorly with complex
8

Published as a conference paper at ICLR 2021
images. More intuitive metrics are in Table 1 and Figure 8 depicts the representation space as a t-SNE
with corresponding observations. Each run took 12 hours on a GTX 1080 GPU.
Figure 8: A t-SNE diagram of encoded ﬁrst-person driving observations after 10k training steps of Algorithm 1,
color coded by value (V in Algorithm 2). Top: the learned representation identiﬁes an obstacle on the right
side. Whether that obstacle is a dark wall, bright car, or truck is task-irrelevant: these states are behaviourally
equivalent. Left: the ego vehicle has ﬂipped onto its left side. The different wall colors, due to a setting sun, is
irrelevant: all states are equally stuck and low-value (purple t-SNE color). Right: clear highway driving. Clouds
and sun position are irrelevant.
0
20000
40000
60000
80000
100000
step
0
25
50
75
100
125
150
175
episode_reward
carla
Contrastive
Reconstruction
SAC
DeepMDP
DBC (ours)
Figure 9: Performance comparison with 3 seeds on the
driving task. Our DBC method (red) performs better
than DeepMDP (purple) or learning direct from pixels
without a representation (SAC, green), and much better
than contrastive methods (blue). Our method’s ﬁnal
performance is 46.8% better than the next best baseline.
Table 1: Driving metrics, averaged over 100 episodes,
after 100k training steps, with standard error. Arrow
direction indicates if metric desired larger or smaller.
SAC
DeepMDP
DBC (ours)
successes (100m) ↑
12%
17%
24%
distance (m)
↑
123.2 ± 7.43
106.7 ± 11.1
179.0 ± 11.4
crash intensity
↓
4604 ± 30.7
1958 ± 15.6
2673 ± 38.5
average steer
↓
16.6% ± 0.019%
10.4% ± 0.015%
7.3% ± 0.012%
average brake
↓
1.3% ± 0.006%
4.3% ± 0.033%
1.6% ± 0.022%
7
Discussion
This paper presents Deep Bisimulation for Control: a new representation learning method that
considers downstream control. Observations are encoded into representations that are invariant to
different task-irrelevant details in the observation. We show this is important when learning control
from outdoor images, or otherwise images with background “distractions”. In contrast to other
bisimulation methods, we show performance gains when distances in representation space match the
bisimulation distance between observations.
Future work: Several options exist for future work. First, our latent dynamics model ˆP was only
used for training our encoder in Equation (4), but could also be used for multi-step planning in latent
space. Second, estimating uncertainty could also be important to produce agents that can work in
the real world, perhaps via an ensemble of models { ˆPk}K
k=1, to detect—and adapt to—distributional
shifts between training and test observations. Third, an undressed issue is that of partially observed
settings (that assumed approximately full observability by using stacked images), possibly using
explicit memory or implicit memory such as an LSTM. Finally, investigating which metrics (L1 or
L2) and dynamics distributions (Gaussians or not) would be beneﬁcial.
9

Published as a conference paper at ICLR 2021
References
Pablo Samuel Castro. Scalable methods for computing state similarity in deterministic Markov
decision processes. In Association for the Advancement of Artiﬁcial Intelligence (AAAI), 2020.
Ting Chen, Simon Kornblith, Mohammad Norouzi, and Geoffrey Hinton. A Simple Framework for
Contrastive Learning of Visual Representations. arXiv:2002.05709 [cs, stat], February 2020. URL
http://arxiv.org/abs/2002.05709. arXiv: 2002.05709.
Kurtland Chua, Roberto Calandra, Rowan McAllister, and Sergey Levine. Deep reinforcement
learning in a handful of trials using probabilistic dynamics models.
In Neural Information
Processing Systems (NeurIPS), pp. 4754–4765, 2018.
Alexey Dosovitskiy, German Ros, Felipe Codevilla, Antonio Lopez, and Vladlen Koltun. CARLA:
An open urban driving simulator. arXiv preprint arXiv:1711.03938, 2017.
Simon S. Du, Akshay Krishnamurthy, Nan Jiang, Alekh Agarwal, Miroslav Dudík, and John Langford.
Provably efﬁcient RL with rich observations via latent state decoding. Computing Research
Repository (CoRR), abs/1901.09018, 2019. URL http://arxiv.org/abs/1901.09018.
Norm Ferns, Prakash Panangaden, and Doina Precup. Metrics for ﬁnite Markov decision processes.
In Uncertainty in Artiﬁcial Intelligence (UAI), pp. 162–169, 2004. ISBN 0-9749039-0-6. URL
http://dl.acm.org/citation.cfm?id=1036843.1036863.
Norm Ferns, Prakash Panangaden, and Doina Precup. Bisimulation metrics for continuous Markov
decision processes. Society for Industrial and Applied Mathematics, 40(6):1662–1714, December
2011. ISSN 0097-5397. doi: 10.1137/10080484X. URL https://doi.org/10.1137/
10080484X.
Norman Ferns and Doina Precup. Bisimulation metrics are optimal value functions. In Uncertainty
in Artiﬁcial Intelligence (UAI), pp. 210–219, 2014.
Carles Gelada, Saurabh Kumar, Jacob Buckman, Oﬁr Nachum, and Marc G. Bellemare. DeepMDP:
Learning continuous latent space models for representation learning. In Kamalika Chaudhuri and
Ruslan Salakhutdinov (eds.), International Conference on Machine Learning (ICML), volume 97,
pp. 2170–2179, Jun 2019.
Robert Givan, Thomas L. Dean, and Matthew Greig. Equivalence notions and model minimization in
Markov decision processes. Artiﬁcial Intelligence, 147:163–223, 2003.
Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-policy maxi-
mum entropy deep reinforcement learning with a stochastic actor. arXiv preprint arXiv:1801.01290,
2018.
Danijar Hafner, Timothy Lillicrap, Ian Fischer, Ruben Villegas, David Ha, Honglak Lee, and James
Davidson. Learning latent dynamics for planning from pixels. arXiv preprint arXiv:1811.04551,
2018.
Olivier J Hénaff, Aravind Srinivas, Jeffrey De Fauw, Ali Razavi, Carl Doersch, SM Eslami, and
Aaron van den Oord. Data-efﬁcient image recognition with contrastive predictive coding. arXiv
preprint arXiv:1905.09272, 2019.
Rico Jonschkowski and Oliver Brock. Learning state representations with robotic priors. Autonomous
Robots, 39(3):407–428, 2015.
Anders Jonsson and Andrew Barto. Causal graph based decomposition of factored MDPs. J. Mach.
Learn. Res., 7:2259–2301, December 2006. ISSN 1532-4435.
Will Kay, João Carreira, Karen Simonyan, Brian Zhang, Chloe Hillier, Sudheendra Vijayanarasimhan,
Fabio Viola, Tim Green, Trevor Back, Paul Natsev, Mustafa Suleyman, and Andrew Zisserman.
The kinetics human action video dataset. Computing Research Repository (CoRR), 2017. URL
http://arxiv.org/abs/1705.06950.
10

Published as a conference paper at ICLR 2021
Sascha Lange and Martin Riedmiller. Deep auto-encoder neural networks in reinforcement learning.
In International Joint Conference on Neural Networks (IJCNN), pp. 1–8. IEEE, 2010.
Sascha Lange, Martin Riedmiller, and Arne Voigtländer. Autonomous reinforcement learning on raw
visual input data in a real world application. In International Joint Conference on Neural Networks
(IJCNN), pp. 1–8, 2012. doi: 10.1109/IJCNN.2012.6252823.
K. G. Larsen and A. Skou. Bisimulation through probabilistic testing (preliminary report). In
Symposium on Principles of Programming Languages, pp. 344–352. Association for Computing
Machinery, 1989. ISBN 0897912942. doi: 10.1145/75277.75307. URL https://doi.org/
10.1145/75277.75307.
Michael Laskin, Aravind Srinivas, and Pieter Abbeel. CURL: Contrastive unsupervised representa-
tions for reinforcement learning. arXiv:2003.06417, 2020.
Alex X Lee, Anusha Nagabandi, Pieter Abbeel, and Sergey Levine. Stochastic latent actor-critic:
Deep reinforcement learning with a latent variable model. arXiv preprint arXiv:1907.00953, 2019.
Lihong Li, Thomas J Walsh, and Michael L Littman. Towards a uniﬁed theory of state abstraction for
MDPs. In ISAIM, 2006.
Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei A. Rusu, Joel Veness, Marc G.
Bellemare, Alex Graves, Martin Riedmiller, Andreas K. Fidjeland, Georg Ostrovski, Stig Pe-
tersen, Charles Beattie, Amir Sadik, Ioannis Antonoglou, Helen King, Dharshan Kumaran,
Daan Wierstra, Shane Legg, and Demis Hassabis.
Human-level control through deep rein-
forcement learning.
Nature, 518(7540):529–533, February 2015.
ISSN 00280836.
URL
http://dx.doi.org/10.1038/nature14236.
Aaron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive
coding. arXiv preprint arXiv:1807.03748, 2018.
Kate Rakelly, Aurick Zhou, Deirdre Quillen, Chelsea Finn, and Sergey Levine. Efﬁcient off-policy
meta-reinforcement learning via probabilistic context variables. arXiv preprint arXiv:1903.08254,
2019.
Bernhard Schölkopf. Causality for machine learning, 2019.
Yuval Tassa, Yotam Doron, Alistair Muldal, Tom Erez, Yazhe Li, Diego de Las Casas, David
Budden, Abbas Abdolmaleki, Josh Merel, Andrew Lefrancq, Timothy Lillicrap, and Martin
Riedmiller. DeepMind control suite. Technical report, DeepMind, January 2018. URL https:
//arxiv.org/abs/1801.00690.
Jonathan Taylor, Doina Precup, and Prakash Panagaden. Bounding performance loss in approximate
MDP homomorphisms. In Neural Information Processing (NeurIPS), pp. 1649–1656, 2009.
Franck van Breugel and James Worrell. Towards quantitative veriﬁcation of probabilistic transition
systems. In Fernando Orejas, Paul G. Spirakis, and Jan van Leeuwen (eds.), Automata, Languages
and Programming, pp. 421–432. Springer, 2001. ISBN 978-3-540-48224-6. doi: 10.1007/
3-540-48224-5_35.
Aäron van den Oord, Yazhe Li, and Oriol Vinyals. Representation learning with contrastive predictive
coding. ArXiv, abs/1807.03748, 2018.
Cédric Villani. Topics in optimal transportation. American Mathematical Society, 01 2003.
Niklas Wahlström, Thomas Schön, and Marc Deisenroth. From pixels to torques: Policy learning
with deep dynamical models. arXiv preprint arXiv:1502.02251, 2015.
Manuel Watter, Jost Springenberg, Joschka Boedecker, and Martin Riedmiller. Embed to control:
A locally linear latent dynamics model for control from raw images. In Neural Information
Processing Systems (NeurIPS), pp. 2728–2736, 2015.
Denis Yarats and Ilya Kostrikov. Soft actor-critic (SAC) implementation in PyTorch. https:
//github.com/denisyarats/pytorch_sac, 2020.
11

Published as a conference paper at ICLR 2021
Denis Yarats, Amy Zhang, Ilya Kostrikov, Brandon Amos, Joelle Pineau, and Rob Fergus. Im-
proving sample efﬁciency in model-free reinforcement learning from images. arXiv preprint
arXiv:1910.01741, 2019.
Amy Zhang, Yuxin Wu, and Joelle Pineau. Natural environment benchmarks for reinforcement
learning. Computing Research Repository (CoRR), abs/1811.06032, 2018. URL http://arxiv.
org/abs/1811.06032.
Amy Zhang, Clare Lyle, Shagun Sodhani, Angelos Filos, Marta Kwiatkowska, Joelle Pineau, Yarin
Gal, and Doina Precup. Invariant causal prediction for block mdps. In International Conference
on Machine Learning (ICML), 2020.
12

Published as a conference paper at ICLR 2021
A
Additional Theorems and Proofs
Theorem 1. Let met be the space of bounded pseudometrics on S and π ∈Π a policy that is
continuously improving in the space of policies Π. Deﬁne F : met × Π 7→met by
F(d, π)(si, sj) = (1 −c)|rπ
si −rπ
sj| + cW(d)(Pπ
si, Pπ
sj).
(9)
Then F has a least ﬁxed point ˜d which is a π∗-bisimulation metric.
Proof. Ideally, to prove this theorem we show that F is monotonically increasing and continuous, and
apply Fixed Point Theorem to show the existence of a ﬁxed point that F converges to. Unfortunately,
we can show that F under π as π monotonically converges to π∗is not also monotonic, unlike the
original bisimulation metric setting (Ferns et al., 2004) and the policy evaluation setting (Castro,
2020). We start the iterates Fn from bottom ⊥, denoted as Fn(⊥). In Ferns et al. (2004) the maxa∈A
can be thought of as learning a policy between every two pairs of states to maximize their distance,
and therefore this distance can only stay the same or grow over iterations of F. In Castro (2020), π is
ﬁxed, and under a deterministic MDP it can also be shown that distance between states dn(si, sj)
will only expand, not contract as n increases. In the policy iteration setting, however, with π starting
from initialization π0 and getting updated:
πk(s) = arg max
a∈A
X
s′∈S
[ra
ss′ + γV πk−1(s′)],
(10)
there is no guarantee that the distance between two states dπk−1
n−1 (si, sj) < dπk
n (si, sj) under policy
iterations πk−1, πk and distance metric iterations dn−1, dn for k, n ∈N, which is required for
monotonicity.
Instead, we show that using the policy improvement theorem which gives us
V πk(s) ≥V πk−1(s), ∀s ∈S,
(11)
π will converge to a ﬁxed point using the Fixed Point Theorem, and taking the result by Castro (2020)
that Fπ has a ﬁxed point for every π ∈Π, we can show that a ﬁxed point bisimulation metric will be
found with policy iteration.
Theorem 2. Given a new aggregated MDP
¯
M constructed by aggregating states in an ϵ-
neighborhood, and an encoder φ that maps from states in the original MDP M to these clusters, the
optimal value functions for the two MDPs are bounded as
|V ∗(s) −V ∗(φ(s))| ≤
2ϵ
(1 −γ)(1 −c).
(12)
Proof. From Theorem 5.1 in Ferns et al. (2004) we have:
(1 −c)|V ∗(s) −V ∗(φ(s))| ≤g(s, ˜d) +
γ
1 −γ max
u∈S g(u, ˜d)
where g is the average distance between a state and all other states in its equivalence class under the
bisimulation metric ˜d. By specifying a ϵ-neighborhood for each cluster of states we can replace g:
(1 −c)|V ∗(s) −V ∗(φ(s))| ≤2ϵ +
γ
1 −γ 2ϵ
|V ∗(s) −V ∗(φ(s))| ≤
1
1 −c(2ϵ +
γ
1 −γ 2ϵ)
=
2ϵ
(1 −γ)(1 −c).
Theorem 4. Given an encoder φ : S 7→Z that maps observations to a latent bisimulation metric
representation where ||φ(si) −φ(sj)||1 := ˜d(si, sj), Z encodes information about all the causal
ancestors of the reward AN(R).
Proof. We assume a MDP with a state space S := {S1, ..., SK} that can be factorized into K
variables with 1-step causal transition dynamics described by a causal graph G (example in Figure 10).
We break the proof up into two parts: 1) show that if a factor Si /∈AN(R) changes, the bisimulation
distance between the original state s and the new state s′ is 0. and 2) show that if a factor Sj ∈AN(R)
changes, the bisimulation distance can be > 0.
13

Published as a conference paper at ICLR 2021
Figure 10: Causal graph of transition dynamics. Reward depends only on s1 as a causal parent, but s1
causally depends on s2, so AN(R) is the set {s1, s2}.
1) If Si /∈AN(R), an intervention on that factor does not affect current or future reward.
˜d(si, sj) = max
a∈A(1 −c)|ra
si −ra
sj| + cW( ˜d)(Pa
si, Pa
sj)
= max
a∈A cW( ˜d)(Pa
si, Pa
sj)
si and sj have the same reward.
If Si does not affect future reward, then states si and sj will have the same future reward conditioned
on all future actions. This gives us
˜d(s, s′) = 0.
2) If there is an intervention on Sj ∈AN(R) then current and/or future reward can change. If
current reward changes, then we already have maxa∈A(1 −c)|ra
si −ra
sj| > 0, giving us ˜d(si, sj) >
0. If only future reward changes, then those future states will have nonzero bisimilarity, and
maxa∈A W( ˜d)(P a
si, P a
sj) > 0, giving us ˜d(si, sj) > 0.
B
Deﬁnition of State
Since we are concerned primarily with learning from image observations, we could explicitly
distinguish the image observation space O from an unknown state space S. However, since we are
not tackling the general POMDP problem, we consider the Block MDP (Du et al., 2019), which
assumes the state space is latent, and that we are instead given access to an observation space O
and rendering function q : S 7→O. The crucial assumption that distinguishes the Block MDP from
partially observable MDPs is the following:
Assumption 1 (Block structure (Du et al., 2019)). Each observation o uniquely determines its
generating state s. That is, the observation space O can be partitioned into disjoint blocks Os, each
containing the support of the conditional distribution q(o|s).
This assumption gives us the Markov property in the observation space o ∈O. As an example,
one can think of the proprioceptive state consisting of positions and velocities of actuators as the
underlying state, and stacked pixel observations from a speciﬁc camera angle as a particular rendering
function and corresponding observation space.
C
Additional DMC Results
In Figure 11 we show performance on the default setting on 9 different environments from DMC.
Figures 12 and 13 give performance on the simple distractors and natural video settings for all 9
environments.
14

Published as a conference paper at ICLR 2021
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
800
AverageReturn
cartpole/swingup
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
800
900
AverageReturn
cheetah/run
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
200
400
600
800
1000
AverageReturn
finger/spin
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
50
100
150
200
250
AverageReturn
hopper/hop
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
800
AverageReturn
hopper/stand
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
100000
200000
300000
400000
500000
600000
700000
800000
step
50
100
150
200
250
300
350
episode_reward
reacher_easy
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
AverageReturn
walker/run
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
100
200
300
400
500
600
700
800
900
1000
AverageReturn
walker/stand
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
200
400
600
800
AverageReturn
walker/walk
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
Figure 11: Results for DBC in the default setting, in comparison to baselines with reconstruction loss,
contrastive loss, and SLAC on 10 seeds with 1 standard error shaded.
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
800
AverageReturn
cartpole/swingup
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
AverageReturn
cheetah/run
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
200
400
600
800
AverageReturn
finger/spin
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
10
20
30
40
50
60
AverageReturn
hopper/hop
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
AverageReturn
hopper/stand
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
100
200
300
400
500
600
AverageReturn
reacher/easy
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
50
100
150
200
250
300
350
AverageReturn
walker/run
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
100
200
300
400
500
600
700
800
900
1000
AverageReturn
walker/stand
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
800
AverageReturn
walker/walk
Figure 12: Results for DBC in the simple distractors setting, in comparison to baselines with
reconstruction loss, contrastive loss, DeepMDP, and SLAC on 10 seeds with 1 standard error shaded.
15

Published as a conference paper at ICLR 2021
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
800
AverageReturn
cartpole/swingup
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
50
100
150
200
250
300
AverageReturn
cheetah/run
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
200
400
600
800
AverageReturn
finger/spin
0
100000
200000
300000
400000
500000
600000
700000
800000
step
0
10
20
30
40
50
60
70
episode_reward
hopper_hop
0
100000
200000
300000
400000
500000
600000
700000
800000
step
0
50
100
150
200
250
300
350
episode_reward
hopper_stand
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
50
100
150
200
250
300
350
400
450
AverageReturn
reacher/easy
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
50
100
150
200
250
300
AverageReturn
walker/run
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
100
200
300
400
500
600
700
800
900
AverageReturn
walker/stand
Contrastive
Reconstruction
Bisim
DeepMDP
SLAC
0
1
2
3
4
5
6
7
8
Environment Steps
1e5
0
100
200
300
400
500
600
700
AverageReturn
walker/walk
Figure 13: Results for our bisimulation metric method in the natural video setting, in comparison to
baselines with reconstruction loss, contrastive loss, DeepMDP, and SLAC on 10 seeds with 1 standard
error shaded.
D
Additional Visualizations
In addition to Figure 4, we also took 10 nearby points in the t-SNE plot and average the observations,
shown on the far left of Figure 14. Note the robot agent is quite crisp, which means neighboring
points encode the agent in similar positions, but the backgrounds are very different, and so are blurry
when averaged.
Figure 14: t-SNE of latent spaces learned with a bisimulation metric after training has completed, color-coded
with predicted state values (higher value yellow, lower value purple). Neighboring points (right) in the embedding
space learned with a bisimulation metric have similar encodings (middle). When we sample from the same latent
point, and average the images, we see the robot conﬁguration is crisp, meaning neighboring points encode the
agent in similar positions, but the backgrounds are very different, and so are blurry when averaged.
16

Published as a conference paper at ICLR 2021
E
Implementation Details
We use the same encoder architecture as in Yarats et al. (2019), which is an almost identical encoder
architecture as in Tassa et al. (2018), with two more convolutional layers to the convnet trunk. The
encoder has kernels of size 3 × 3 with 32 channels for all the convolutional layers and set stride to 1
everywhere, except of the ﬁrst convolutional layer, which has stride 2, and interpolate with ReLU
activations. Finally, we add tanh nonlinearity to the 50 dimensional output of the fully-connected
layer.
For the reconstruction method, the decoder consists of a fully-connected layer followed by four
deconvolutional layers. We use ReLU activations after each layer, except the ﬁnal deconvolutional
layer that produces pixels representation. Each deconvolutional layer has kernels of size 3 × 3 with
32 channels and stride 1, except of the last layer, where stride is 2.
The dynamics and reward models are both MLPs with two hidden layers with 200 neurons each and
ReLU activations.
Soft Actor Critic (SAC) (Haarnoja et al., 2018) is an off-policy actor-critic method that uses the
maximum entropy framework for soft policy iteration. At each iteration, SAC performs soft policy
evaluation and improvement steps. The policy evaluation step ﬁts a parametric soft Q-function
Q(st, at) using transitions sampled from the replay buffer D by minimizing the soft Bellman residual,
J(Q) = E(st,st,rt,st+1)∼D

Q(st, at) −rt −γ ¯V (st+1)
2
.
(13)
The target value function ¯V is approximated via a Monte-Carlo estimate of the following expectation,
¯V (st+1) = Eat+1∼π
 ¯Q(st+1, at+1) −α log π(at+1|st+1)

,
(14)
where ¯Q is the target soft Q-function parameterized by a weight vector obtained from an exponentially
moving average of the Q-function weights to stabilize training. The policy improvement step then
attempts to project a parametric policy π(at|st) by minimizing KL divergence between the policy
and a Boltzmann distribution induced by the Q-function, producing the following objective,
J(π) = Est∼D

Eat∼π[α log(π(at|st)) −Q(st, at)]

.
(15)
We modify the Soft Actor-Critic PyTorch implementation by Yarats & Kostrikov (2020) and augment
with a shared encoder between the actor and critic, the general model fs and task-speciﬁc models f e
η.
The forward models are multi-layer perceptions with ReLU non-linearities and two hidden layers of
200 neurons each. The encoder is a linear layer that maps to a 50-dim hidden representation. The
hyperparameters used for the RL experiments are in Table 2.
Parameter name
Value
Replay buffer capacity
106
Batch size
128
Discount γ
0.99
Optimizer
Adam
Critic learning rate
10−5
Critic target update frequency
2
Critic Q-function soft-update rate τQ
0.005
Critic encoder soft-update rate τφ
0.005
Actor learning rate
10−5
Actor update frequency
2
Actor log stddev bounds
[−5, 2]
Encoder learning rate
10−5
Decoder learning rate
10−5
Decoder weight decay
10−7
Temperature learning rate
10−4
Temperature Adam’s β1
0.9
Init temperature
0.1
Table 2: A complete overview of used hyper parameters.
17

